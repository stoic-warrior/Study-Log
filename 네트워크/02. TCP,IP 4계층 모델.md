# 개요
- **인터넷 프로토콜 스위트(Internet Protocol Suite)** = 인터넷에서 컴퓨터들이 서로 정보를 주고받을 때 사용하는 **프로토콜의 집합**이다.
- 이를 설명하는 모델이 두 가지가 있다:
  - **TCP/IP 4계층 모델**
  - **OSI 7계층 모델**
- 여기서는 **TCP/IP 모델**을 중심으로 설명한다.
# 계층 구조
- <img width="506" height="426" alt="image" src="https://github.com/user-attachments/assets/8276df12-7333-4bb5-b60f-564b4e9b99eb" />
- <img width="473" height="412" alt="image" src="https://github.com/user-attachments/assets/7e861017-b704-4db6-a66b-a111e0751b58" />

- 각 계층은 **독립적**으로 동작하면서 위·아래 계층과 협력한다
  - 독립적이다 : TCP를 UDP로 바꾸었다고 인터넷 웹 브라우저를 재설치해야되고 그러지 않는다
- OSI 7계층
  - 애플리케이션 계층 → 애플리케이션/프레젠테이션/세션 계층
  - 인터넷 계층 → 네트워크 계층
  - 링크 계층 → 데이터 링크/물리 계층
## 애플리케이션 계층
- 임무: 사용자와 가장 가까운 계층. 실제 ‘서비스’가 동작하는 영역.
- 대표 프로토콜: HTTP, HTTPS, FTP, SMTP, DNS, SSH
- 데이터 단위: 메시지(Message)
> 즉, 브라우저가 “GET /index.html”을 보낼 때 이 계층에서 시작된다.
> 여기서 만들어진 메시지가 아래 계층으로 ‘캡슐화’되어 내려간다
## 전송 계층
- 임무: 프로세스 간 통신을 담당. (IP는 호스트 간, TCP/UDP는 프로세스 간)
- 대표 프로토콜: TCP, UDP
- 데이터 단위: 세그먼트(Segment, TCP) / 데이터그램(Datagram, UDP)
### 가상 회선 패킷 교환 방식
<img width="753" height="546" alt="image" src="https://github.com/user-attachments/assets/6dd57131-6d0d-4010-ab6e-f2f507fc28fb" />

> 통신 시작 시 경로를 미리 설정하고, 그 경로로만 데이터 전송
- TCP가 사용하는 방식.
- 연결을 먼저 설정(3-way handshake)하고, 데이터 전송 후 해제.
- 모든 패킷이 동일한 경로를 따라가며 순서가 보장됨.
- 장점: 신뢰성, 순서 보장
- 단점: 연결 설정/해제 오버헤드
### 데이터그램 패킷 교환 방식
<img width="756" height="548" alt="image" src="https://github.com/user-attachments/assets/eb3a13fb-9ca6-4229-a703-4e31e14df3be" />

> 각 패킷이 독립적으로 경로를 선택해 전달됨
- UDP가 사용하는 방식.
- 연결 설정 없이 바로 전송.
- 패킷 순서나 신뢰성 보장 없음. (VoIP, 실시간 스트리밍에 적합)
- 장점: 빠름, 단순
- 단점: 순서/신뢰성 보장 안 됨
### TCP 연결 성립 과정 (3-way Handshake)
<img width="683" height="653" alt="image" src="https://github.com/user-attachments/assets/2b1aa889-6471-411a-bea9-79dea296ee5d" />

- SYN – 클라이언트가 연결 요청 (이때 클라이언트는 자신의 초기 시퀀스 번호(ISN)를 보낸다.)
- SYN + ACK – 서버가 요청 수락 응답 (서버가 자신의 ISN과, 클라이언트의 ISN에 +1한 값 두 개를 보내서 수락(ACK)한다.)
- ACK – 클라이언트가 수락 확인 (서버의 ISN에 +1을 한 값을 보내서 수락한다)
- → 연결 성립
### TCP 연결 해제 과정 (4-way Handshake)
<img width="569" height="352" alt="image" src="https://github.com/user-attachments/assets/49b82f11-587b-450b-afa1-2f113a5e3269" />

- 클라이언트 → FIN (이를 Active Close라고 함)
  - 클라이언트 상태: `ESTABLISHED → FIN_WAIT_1`
  - 서버 상태: `ESTABLISHED → CLOSE_WAIT`
- 서버 → ACK (하지만 서버는 아직 클라이언트에게 보낼 데이터가 남아있을 수 있음)
  - 클라이언트 상태: `FIN_WAIT_1 → FIN_WAIT_2`
  - 서버 상태: 여전히 ` CLOSE_WAIT`
- 서버 → FIN (서버도 이제 전송을 모두 마쳤음을 통보)
  - 서버 상태: `CLOSE_WAIT → LAST_ACK`
- 클라이언트 → ACK (클라이언트가 서버의 FIN을 수신하고 ACK로 응답)
  - 클라이언트 상태: `TIME_WAIT → CLOSED` (일정 시간 기다린 후 완전히 종료)
  - 서버 상태: `LAST_ACK → CLOSED`
- → 연결 종료
#### ⏳ TIME_WAIT 상태의 이유
> TIME_WAIT은 안전한 종료를 보장하기 위한 보호 단계다
- ① 지연 패킷(Late Packet) 방지
  - 네트워크는 완벽하지 않다.
  - 어떤 패킷은 전송이 지연되거나 순서가 뒤바뀌어 늦게 도착할 수 있다.
  - 만약 연결을 바로 닫아버리면,
  - 이전 세션의 늦은 패킷이 새 연결의 데이터로 오인되어 처리될 위험이 있다.
  - 예를 들어, 100개의 패킷 중 마지막 하나가 지연되어 뒤늦게 도착하면
  - 이미 닫힌 연결이라도 데이터가 꼬일 수 있다.
- ② 연결 종료의 완전성 확인
  - 클라이언트는 마지막으로 ACK를 보냈지만,
  - 이 ACK이 손실될 수도 있다.
  - 만약 이때 바로 닫아버리면,
  - 서버는 FIN을 재전송하게 되고, 클라이언트는 이미 닫힌 상태이므로
  - 새 연결과 충돌하거나 “포트 재사용 오류”가 발생할 수 있다.
  - TIME_WAIT 동안 클라이언트는 이 **재전송 FIN을 받아 처리(ACK 재전송)**할 준비를 한다.
## 인터넷 계층
## 링크 계층
### 유선 LAN(IEEE802.3)
#### 전이중화 통신
#### CSMA/CD
### 유선 LAN을 이루는 케이블
#### 트위스트 페어 케이블
#### 광섬유 케이블
### 유선 LAN(IEEE802.11)
#### 반이중화 통신
#### CSMA/CA
### 무선 LAN을 이루는 주파수
#### 와이파이
#### BSS
#### ESS
### 이더넷 프레임
## 계층 간 데이터 송수신 과정
### 캡슐화 과정
### 비캡슐화 과정
# PUD
