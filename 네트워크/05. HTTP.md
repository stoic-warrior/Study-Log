# HTTP/1.0
> 요청 하나 = 연결 하나
- 요청마다 TCP 연결 생성
- 리소스 하나 받을 때마다 3-way handshake 반복
## RTT 증가
<img width="396" height="453" alt="image" src="https://github.com/user-attachments/assets/7ebe489b-bbad-4a00-b65b-af42d3622715" />

- RTT(Round Trip Time)란?
  - 요청을 보내고 응답을 받기까지 걸리는 왕복 시간
  - 클라이언트 → 서버 → 클라이언트
- HTTP/1.0에서 RTT가 폭증하는 이유
  - 요청마다 TCP 3-way handshake 반복해야  
## RTT의 증가를 해결하기 위한 방법 
### 이미지 스플리팅 (Image Spriting)
- 여러 이미지를 하나의 큰 이미지로 합침
- CSS background-position으로 필요한 부분만 표시
- 📌 단점
  - 수정 시 전체 이미지 재배포
### 코드 압축 (Minify)
- JS, CSS에서 공백/주석 제거
- 파일 크기 감소 → 전송 시간 감소
- **RTT 자체는 줄이지 못함**
  - → “한 번의 왕복에 실리는 짐만 줄임”
### 이미지 Base64 인코딩 
- 이미지를 문자열로 변환해 HTML/CSS에 인라인 삽입
- HTTP 요청 수 감소
- 📌 단점
  - 용량 약 33% 증가
# HTTP/1.1
> 연결 재사용의 시작
- 하나의 TCP 연결로 여러 요청 처리
- Persistent Connection (Keep-Alive) 기본 지원
## HOL Blocking (Head Of Line Blocking)
<img width="774" height="244" alt="image" src="https://github.com/user-attachments/assets/2f3b8f67-58d8-47fa-9fc3-012dcdf541fe" />

- 같은 TCP 연결 안에서 요청은 순차 처리
- 앞 요청이 느리면 뒤 요청 전부 대기
- 📌 예시
```
[HTML 요청] → 느림
[CSS 요청] → 대기
[JS 요청] → 대기
```
- 👉 병목 하나가 전체를 막는다.
## 무거운 헤더 구조
- HTTP/1.1은 헤더가 무거웠다 
# HTTP/2
> 성능 혁명 
- TCP 위에서 동작
- 대부분 HTTPS 강제
## 멀티플렉싱 (Multiplexing)
<img width="796" height="208" alt="image" src="https://github.com/user-attachments/assets/8d393f2b-af7d-475e-8b5e-bacf87246a7b" />

> 단일 연결에서 병렬 처리
- 여러 개의 스트림을 통해 송수신
- **스트림** : 하나의 결과를 만드는 데이터 흐름
- 여러 요청/응답을 프레임 단위로 쪼개 병렬 전송
- 📌 결과
  - 요청 순서 상관없이 응답 가능
  - HTTP/1.1 HOL Blocking 해결
- ⚠️ 단, TCP 레벨 HOL은 여전히 존재
<img width="607" height="329" alt="image" src="https://github.com/user-attachments/assets/ba7bdc8c-50c9-4f8d-a6d1-3c92a12e1891" />

## 헤더 압축 (HPACK)
<img width="647" height="284" alt="image" src="https://github.com/user-attachments/assets/cf8d6164-8704-4b9d-ac79-49a65e26f173" />

- HPACK 압축형식 : 허프만 코딩 압축 알고리즘을 사용하여 헤더 압축
### 허프만 코딩
- 자주 등장하는 문자열에 **짧은 비트 코드 부여**
- 엔트로피 기반 압축
## 서버 푸시 (Server Push)
<img width="647" height="377" alt="image" src="https://github.com/user-attachments/assets/1bd8157e-7ac9-451e-8ed9-19e1b99c0a9d" />

> 요청 전 리소스 선전송
- HTTP/1.1에서는 클라이언트가 요청을 해야 전송했지만
- HTTP/2는 요청전에 서버가 '클라이언트가 필요할 리소스'를 미리 전송
- ex) html을 읽으며 그 안에 필요한 css나 js를 미리 서버에서 푸시 
# HTTPS 
> 보안을 옵션이 아니라 기본으로
- HTTP + TLS
- HTTP/2.0은 HTTPS 위에서 동작
- 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣
## SSL/TLS 
<img width="830" height="349" alt="image" src="https://github.com/user-attachments/assets/da1d2aa2-00d8-42b4-b963-4489ed7cdd96" />

> 보안 세션 만드는 역할
- SSL으로 시작해서 계속 버전업이 되며 TLS로 명칭이 바뀌었다
- TLS Handshake를 통해 보안 세션 생성
- ✔ 서로를 확인하고
- ✔ 안전한 비밀키를 만들고
- ✔ 그 키로만 대화하는 “보안 세션”을 만든다.
- 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 등 사용 
### 보안 세션
> 보안이 시작되고 끝나는 동안 유지되는 세션
- 클라이언트가 지원 사이퍼 슈트 목록을 보냄
- 서버가 하나 선택 + 인증서 전송
- 키 교환(ECDHE) → 세션 키 확정
- 이후 트래픽은 선택된 AEAD 암호로 암호화
#### 사이퍼 슈트(Cipher Suite)
> TLS 연결에서 쓸 암호 규약 묶음
- TLS 1.3에선 다음 요소들로 구성된다:
  - **프로토콜**: TLS
  - **대칭 암호 + AEAD 모드**: AES-GCM, ChaCha20-Poly1305 등
  - **해시**: SHA-256, SHA-384 등
 <img width="425" height="203" alt="image" src="https://github.com/user-attachments/assets/0dee4052-d787-4fdc-b66d-b77f6ad1adde" />

#### AEAD 사이퍼 모드
- 암호화 + 무결성 검증 동시 제공
- AES-GCM, ChaCha20-Poly1305
- 👉 성능 + 보안 둘 다 잡음
### 인증 메커니즘
- “이 서버가 진짜냐?”를 증명하는 장치
- 브라우저는 CA가 서명한 인증서를 믿고 서버를 신뢰한다.
- 인증서에 들어있는 것
  - 서버 정보(도메인 등)
  - 공개키
  - CA의 디지털 서명 (이게 핵심)
#### CA 발급 과정 (흐름만)
> **CA 인증** : 서버의 공개키가 진짜라는 걸 제3자가 보증해주는 시스템
- 서버가 개인키/공개키 쌍 생성
- 공개키 + 사이트 정보(CSR)를 CA에 제출
- CA가 도메인 소유 확인
- CA가 공개키 해시를 자신의 개인키로 서명
- 그 결과가 인증서
#### 접속 시 브라우저가 하는 일
- 서버가 인증서 전달
- 브라우저가 **CA 공개키**로 서명 검증
- 검증되면 “이 서버 진짜”라고 판단
- 이후 키 교환 → 암호화 통신
#### 개인키 / 공개키 핵심
- **개인키**: 서버만 소유 (절대 유출되면 안 됨)
- **공개키**: 인증서에 담겨 전 세계에 공개
### 키 교환 암호화 알고리즘 (DHE / ECDHE)
- **목적** : 서로 만나지 않고도 “같은 비밀키”를 만드는 것
#### 디피-헬만 키 교환 암호화 알고리즘 
`y = g^x mod p`
- 앞으로 계산(g^x mod p): 쉽다
- 뒤로 계산(x 찾기): 매우 어렵다
- 👉 이 “비대칭 난이도”가 보안의 근본이다.
##### 동작흐름
<img width="518" height="648" alt="image" src="https://github.com/user-attachments/assets/484cd573-f413-417b-a777-1fabff4cf165" />

- 공개 값(g, p) 를 서로 공유
- 각자 비밀 값(x, y) 선택
- 공개 값과 비밀 값을 섞은 혼합 값을 교환
- 받은 혼합 값 + 내 비밀 값 → 같은 결과(공통 비밀키) 생성
- 공격자는:
  - 공개 값도 보고
  - 혼합 값도 보지만
  - 비밀 값이 없어서 공통 키를 못 만든다
### 해싱 알고리즘 
#### SHA-256 알고리즘
## SEO에도 도움이 되는 HTTPS 
### 캐노니컬 설정
### 메타 설정
### 페이지 속도 개선
### 사이트맵 관리
## HTTPS 구축 방법
# HTTP/3
## 초기 연결 설정 시 지연 시간 감소
