# HTTP/1.0
> 요청 하나 = 연결 하나
- 요청마다 TCP 연결 생성
- 리소스 하나 받을 때마다 3-way handshake 반복
## RTT 증가
<img width="396" height="453" alt="image" src="https://github.com/user-attachments/assets/7ebe489b-bbad-4a00-b65b-af42d3622715" />

- RTT(Round Trip Time)란?
  - 요청을 보내고 응답을 받기까지 걸리는 왕복 시간
  - 클라이언트 → 서버 → 클라이언트
- HTTP/1.0에서 RTT가 폭증하는 이유
  - 요청마다 TCP 3-way handshake 반복해야  
## RTT의 증가를 해결하기 위한 방법 
### 이미지 스플리팅 (Image Spriting)
- 여러 이미지를 하나의 큰 이미지로 합침
- CSS background-position으로 필요한 부분만 표시
- 📌 단점
  - 수정 시 전체 이미지 재배포
### 코드 압축 (Minify)
- JS, CSS에서 공백/주석 제거
- 파일 크기 감소 → 전송 시간 감소
- **RTT 자체는 줄이지 못함**
  - → “한 번의 왕복에 실리는 짐만 줄임”
### 이미지 Base64 인코딩 
- 이미지를 문자열로 변환해 HTML/CSS에 인라인 삽입
- HTTP 요청 수 감소
- 📌 단점
  - 용량 약 33% 증가
# HTTP/1.1
> 연결 재사용의 시작
- 하나의 TCP 연결로 여러 요청 처리
- Persistent Connection (Keep-Alive) 기본 지원
## HOL Blocking (Head Of Line Blocking)
<img width="774" height="244" alt="image" src="https://github.com/user-attachments/assets/2f3b8f67-58d8-47fa-9fc3-012dcdf541fe" />

- 같은 TCP 연결 안에서 요청은 순차 처리
- 앞 요청이 느리면 뒤 요청 전부 대기
- 📌 예시
```
[HTML 요청] → 느림
[CSS 요청] → 대기
[JS 요청] → 대기
```
- 👉 병목 하나가 전체를 막는다.
## 무거운 헤더 구조
- HTTP/1.1은 헤더가 무거웠다 
# HTTP/2
> 성능 혁명 
- TCP 위에서 동작
- 대부분 HTTPS 강제
## 멀티플렉싱 (Multiplexing)
<img width="796" height="208" alt="image" src="https://github.com/user-attachments/assets/8d393f2b-af7d-475e-8b5e-bacf87246a7b" />

> 단일 연결에서 병렬 처리
- 여러 개의 스트림을 통해 송수신
- **스트림** : 하나의 결과를 만드는 데이터 흐름
- 여러 요청/응답을 프레임 단위로 쪼개 병렬 전송
- 📌 결과
  - 요청 순서 상관없이 응답 가능
  - HTTP/1.1 HOL Blocking 해결
- ⚠️ 단, TCP 레벨 HOL은 여전히 존재
<img width="607" height="329" alt="image" src="https://github.com/user-attachments/assets/ba7bdc8c-50c9-4f8d-a6d1-3c92a12e1891" />

## 헤더 압축 (HPACK)
<img width="647" height="284" alt="image" src="https://github.com/user-attachments/assets/cf8d6164-8704-4b9d-ac79-49a65e26f173" />

- HPACK 압축형식 : 허프만 코딩 압축 알고리즘을 사용하여 헤더 압축
### 허프만 코딩
- 자주 등장하는 문자열에 **짧은 비트 코드 부여**
- 엔트로피 기반 압축
## 서버 푸시 (Server Push)
<img width="647" height="377" alt="image" src="https://github.com/user-attachments/assets/1bd8157e-7ac9-451e-8ed9-19e1b99c0a9d" />

> 요청 전 리소스 선전송
- HTTP/1.1에서는 클라이언트가 요청을 해야 전송했지만
- HTTP/2는 요청전에 서버가 '클라이언트가 필요할 리소스'를 미리 전송
- ex) html을 읽으며 그 안에 필요한 css나 js를 미리 서버에서 푸시 
# HTTPS 
> 보안을 옵션이 아니라 기본으로
- HTTP + TLS
- HTTP/2.0은 HTTPS 위에서 동작
- 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣
## SSL/TLS 
<img width="830" height="349" alt="image" src="https://github.com/user-attachments/assets/da1d2aa2-00d8-42b4-b963-4489ed7cdd96" />

> 보안 세션 만드는 역할
- SSL으로 시작해서 계속 버전업이 되며 TLS로 명칭이 바뀌었다
- TLS Handshake를 통해 보안 세션 생성
- ✔ 서로를 확인하고
- ✔ 안전한 비밀키를 만들고
- ✔ 그 키로만 대화하는 “보안 세션”을 만든다.
- 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 등 사용 
### 보안 세션
> 보안이 시작되고 끝나는 동안 유지되는 세션
- 클라이언트가 지원 사이퍼 슈트 목록을 보냄
- 서버가 하나 선택 + 인증서 전송
- 키 교환(ECDHE) → 세션 키 확정
- 이후 트래픽은 선택된 AEAD 암호로 암호화
#### 사이퍼 슈트(Cipher Suite)
> TLS 연결에서 쓸 암호 규약 묶음
- TLS 1.3에선 다음 요소들로 구성된다:
  - **프로토콜**: TLS
  - **대칭 암호 + AEAD 모드**: AES-GCM, ChaCha20-Poly1305 등
  - **해시**: SHA-256, SHA-384 등
 <img width="425" height="203" alt="image" src="https://github.com/user-attachments/assets/0dee4052-d787-4fdc-b66d-b77f6ad1adde" />

#### AEAD 사이퍼 모드
- 암호화 + 무결성 검증 동시 제공
- AES-GCM, ChaCha20-Poly1305
- 👉 성능 + 보안 둘 다 잡음
### 인증 메커니즘
- “이 서버가 진짜냐?”를 증명하는 장치
- 브라우저는 CA가 서명한 인증서를 믿고 서버를 신뢰한다.
- 인증서에 들어있는 것
  - 서버 정보(도메인 등)
  - 공개키
  - CA의 디지털 서명 (이게 핵심)
#### CA 발급 과정 (흐름만)
> **CA 인증** : 서버의 공개키가 진짜라는 걸 제3자가 보증해주는 시스템
- 서버가 개인키/공개키 쌍 생성
- 공개키 + 사이트 정보(CSR)를 CA에 제출
- CA가 도메인 소유 확인
- CA가 공개키 해시를 자신의 개인키로 서명
- 그 결과가 인증서
#### 접속 시 브라우저가 하는 일
- 서버가 인증서 전달
- 브라우저가 **CA 공개키**로 서명 검증
- 검증되면 “이 서버 진짜”라고 판단
- 이후 키 교환 → 암호화 통신
#### 개인키 / 공개키 핵심
- **개인키**: 서버만 소유 (절대 유출되면 안 됨)
- **공개키**: 인증서에 담겨 전 세계에 공개
### 키 교환 암호화 알고리즘 (DHE / ECDHE)
- **목적** : 서로 만나지 않고도 “같은 비밀키”를 만드는 것
#### 디피-헬만 키 교환 암호화 알고리즘 
`y = g^x mod p`
- 앞으로 계산(g^x mod p): 쉽다
- 뒤로 계산(x 찾기): 매우 어렵다
- 👉 이 “비대칭 난이도”가 보안의 근본이다.
##### 동작흐름
<img width="518" height="648" alt="image" src="https://github.com/user-attachments/assets/484cd573-f413-417b-a777-1fabff4cf165" />

- 공개 값(g, p) 를 서로 공유
- 각자 비밀 값(x, y) 선택
- 공개 값과 비밀 값을 섞은 혼합 값을 교환
- 받은 혼합 값 + 내 비밀 값 → 같은 결과(공통 비밀키) 생성
- 공격자는:
  - 공개 값도 보고
  - 혼합 값도 보지만
  - 비밀 값이 없어서 공통 키를 못 만든다
### 해싱 알고리즘 
> 임의 길이의 데이터를 → 고정 길이의 값으로 바꾸는 알고리즘
- 일방향성: 결과로 원문 추정 불가
- 고정 길이: 입력이 얼마든 출력은 일정
- 눈사태 효과: 1비트만 바뀌어도 결과 완전 변경
- 충돌 저항성: 다른 입력이 같은 해시 나오기 매우 어려움
#### SHA-256 알고리즘
- 출력 길이 256비트
- TLS, 인증서 서명, 무결성 검증, 블록체인에서 사용
- 입력이 같으면 항상 같은 해시
- 입력이 조금만 달라도 완전히 다른 해시
## SEO에도 도움이 되는 HTTPS 
- SEO : 검색엔진 최적화. 검색 페이지 상단에 노출될 확률을 높임 
- 같은 조건이면 HTTPS 사이트를 더 우대한다. (구글 공식 입장)
## SEO 기본 구성요소
### 캐노니컬 설정
- 중복 URL을 하나로 지정
```
<link rel="canonical" href="https://example.com/page">
```
- → 검색엔진 혼란 방지 
### 메타 설정
- `<title>`, `<meta description>`은 검색 결과에 직접 영향
- 페이지마다 **고유** + **명확**하게
### 페이지 속도 개선
- 느리면 탈락
- Google PageSpeed Insights로 LCP / FCP / CLS 관리
- HTTPS + HTTP/2 + 캐시가 핵심
### 사이트맵(sitemap.xml) 관리
- 검색엔진에게 페이지 구조 안내
- HTTPS 기준 URL로 작성
```
<loc>https://example.com/</loc>
```
## HTTPS 구축 방법
- 서버에 직접 인증서 설치
  - CA에서 인증서 발급 → Nginx/Apache에 적용
  - 가장 정석, 설정·운영 직접 관리
- 로드밸런서에서 TLS 종료(TLS Termination)
  - 로드밸런서가 HTTPS 처리
  - 뒤쪽 서버는 HTTP
  - 운영 편함, 대규모 서비스 표준
- CDN에서 HTTPS 제공
  - CDN이 인증서·TLS 처리
  - 전 세계 엣지에서 암호화 + 캐시
  - 성능/보안/SEO 모두 유리
# HTTP/3
> TCP를 버리고 QUIC으로 지연과 병목을 줄인 버전
- UDP 기반 QUIC 프로토콜
- TCP HOL Blocking 제거
- 연결 이동성 (WiFi → LTE)
## 초기 연결 설정 시 지연 시간 감소
- QUIC 특징
  - 0-RTT / 1-RTT Handshake
  - TLS 기본 내장
  - 패킷 손실이 스트림 전체를 막지 않음
- 👉 모바일 환경에서 압도적
