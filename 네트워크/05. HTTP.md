# HTTP/1.0
> 요청 하나 = 연결 하나
- 요청마다 TCP 연결 생성
- 리소스 하나 받을 때마다 3-way handshake 반복
## RTT 증가
<img width="396" height="453" alt="image" src="https://github.com/user-attachments/assets/7ebe489b-bbad-4a00-b65b-af42d3622715" />

- RTT(Round Trip Time)란?
  - 요청을 보내고 응답을 받기까지 걸리는 왕복 시간
  - 클라이언트 → 서버 → 클라이언트
- HTTP/1.0에서 RTT가 폭증하는 이유
  - 요청마다 TCP 3-way handshake 반복해야  
## RTT의 증가를 해결하기 위한 방법 
### 이미지 스플리팅 (Image Spriting)
- 여러 이미지를 하나의 큰 이미지로 합침
- CSS background-position으로 필요한 부분만 표시
- 📌 단점
  - 수정 시 전체 이미지 재배포
### 코드 압축 (Minify)
- JS, CSS에서 공백/주석 제거
- 파일 크기 감소 → 전송 시간 감소
- **RTT 자체는 줄이지 못함**
  - → “한 번의 왕복에 실리는 짐만 줄임”
### 이미지 Base64 인코딩 
- 이미지를 문자열로 변환해 HTML/CSS에 인라인 삽입
- HTTP 요청 수 감소
- 📌 단점
  - 용량 약 33% 증가
# HTTP/1.1
> 연결 재사용의 시작
- 하나의 TCP 연결로 여러 요청 처리
- Persistent Connection (Keep-Alive) 기본 지원
## HOL Blocking (Head Of Line Blocking)
<img width="774" height="244" alt="image" src="https://github.com/user-attachments/assets/2f3b8f67-58d8-47fa-9fc3-012dcdf541fe" />

- 같은 TCP 연결 안에서 요청은 순차 처리
- 앞 요청이 느리면 뒤 요청 전부 대기
- 📌 예시
```
[HTML 요청] → 느림
[CSS 요청] → 대기
[JS 요청] → 대기
```
- 👉 병목 하나가 전체를 막는다.
## 무거운 헤더 구조
- HTTP/1.1은 헤더가 무거웠다 
# HTTP/2
> 성능 혁명 
- TCP 위에서 동작
- 대부분 HTTPS 강제
## 멀티플렉싱 (Multiplexing)
<img width="796" height="208" alt="image" src="https://github.com/user-attachments/assets/8d393f2b-af7d-475e-8b5e-bacf87246a7b" />

> 단일 연결에서 병렬 처리
- 여러 개의 스트림을 통해 송수신
- **스트림** : 하나의 결과를 만드는 데이터 흐름
- 여러 요청/응답을 프레임 단위로 쪼개 병렬 전송
- 📌 결과
- 요청 순서 상관없이 응답 가능
- HTTP/1.1 HOL Blocking 해결
- ⚠️ 단, TCP 레벨 HOL은 여전히 존재
<img width="607" height="329" alt="image" src="https://github.com/user-attachments/assets/ba7bdc8c-50c9-4f8d-a6d1-3c92a12e1891" />

## 헤더 압축 (HPACK)
<img width="647" height="284" alt="image" src="https://github.com/user-attachments/assets/cf8d6164-8704-4b9d-ac79-49a65e26f173" />

- HPACK 압축형식 : 허프만 코딩 압축 알고리즘을 사용하여 헤더 압축
### 허프만 코딩
- 자주 등장하는 문자열에 **짧은 비트 코드 부여**
- 엔트로피 기반 압축
## 서버 푸시 (Server Push)
<img width="647" height="377" alt="image" src="https://github.com/user-attachments/assets/1bd8157e-7ac9-451e-8ed9-19e1b99c0a9d" />

> 요청 전 리소스 선전송
- HTTP/1.1에서는 클라이언트가 요청을 해야 전송했지만
- HTTP/2는 요청전에 서버가 '클라이언트가 필요할 리소스'를 미리 전송
- ex) html을 읽으며 그 안에 필요한 css나 js를 미리 서버에서 푸시 
# HTTPS 
> 보안을 옵션이 아니라 기본으로
- HTTP + TLS
- HTTP/2.0은 HTTPS 위에서 동작
- 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣
## SSL/TLS 
<img width="830" height="349" alt="image" src="https://github.com/user-attachments/assets/da1d2aa2-00d8-42b4-b963-4489ed7cdd96" />

> 보안 세션 만드는 역할
- SSL으로 시작해서 계속 버전업이 되며 TLS로 명칭이 바뀌었다
- ✔ 서로를 확인하고
- ✔ 안전한 비밀키를 만들고
- ✔ 그 키로만 대화하는 “보안 세션”을 만든다.
- 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 등 사용 
### 보안 세션
#### 사이퍼 슈트
#### AEAD 사이퍼 모드
### 인증 메커니즘
#### CA 발급 과정 
### 암호화 알고리즘
#### 디피-헬만 키 교환 암호화 알고리즘 
### 해싱 알고리즘 
#### SHA-256 알고리즘
## SEO에도 도움이 되는 HTTPS 
### 캐노니컬 설정
### 메타 설정
### 페이지 속도 개선
### 사이트맵 관리
## HTTPS 구축 방법
# HTTP/3
## 초기 연결 설정 시 지연 시간 감소
