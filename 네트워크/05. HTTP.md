# HTTP/1.0
> 요청 하나 = 연결 하나
- 요청마다 TCP 연결 생성
- 리소스 하나 받을 때마다 3-way handshake 반복
## RTT 증가
<img width="396" height="453" alt="image" src="https://github.com/user-attachments/assets/7ebe489b-bbad-4a00-b65b-af42d3622715" />

- RTT(Round Trip Time)란?
  - 요청을 보내고 응답을 받기까지 걸리는 왕복 시간
  - 클라이언트 → 서버 → 클라이언트
- HTTP/1.0에서 RTT가 폭증하는 이유
  - 요청마다 TCP 3-way handshake 반복해야  
## RTT의 증가를 해결하기 위한 방법 
### 이미지 스플리팅 (Image Spriting)
- 여러 이미지를 하나의 큰 이미지로 합침
- CSS background-position으로 필요한 부분만 표시
- 📌 단점
  - 수정 시 전체 이미지 재배포
### 코드 압축 (Minify)
- JS, CSS에서 공백/주석 제거
- 파일 크기 감소 → 전송 시간 감소
- **RTT 자체는 줄이지 못함**
  - → “한 번의 왕복에 실리는 짐만 줄임”
### 이미지 Base64 인코딩 
- 이미지를 문자열로 변환해 HTML/CSS에 인라인 삽입
- HTTP 요청 수 감소
- 📌 단점
  - 용량 약 33% 증가
# HTTP/1.1
> 연결 재사용의 시작
- 하나의 TCP 연결로 여러 요청 처리
- Persistent Connection (Keep-Alive) 기본 지원
## HOL Blocking (Head Of Line Blocking)
- 같은 TCP 연결 안에서 요청은 순차 처리
- 앞 요청이 느리면 뒤 요청 전부 대기
- 📌 예시
```
[HTML 요청] → 느림
[CSS 요청] → 대기
[JS 요청] → 대기
```
- 👉 병목 하나가 전체를 막는다.
## 무거운 헤더 구조
- HTTP/1.1은 헤더가 무거웠다 
# HTTP/2
> 성능 혁명 
- TCP 위에서 동작
- 대부분 HTTPS 강제
## 멀티플렉싱 (Multiplexing)
- 하나의 TCP 연결
- 여러 요청/응답을 프레임 단위로 쪼개 병렬 전송
- 📌 결과
- 요청 순서 상관없이 응답 가능
- HTTP/1.1 HOL Blocking 해결
- ⚠️ 단, TCP 레벨 HOL은 여전히 존재
## 헤더 압축
### 허프만 코딩
## 서버 푸시
# HTTPS 
## SSL/TLS 
### 보안 세션
#### 사이퍼 슈트
#### AEAD 사이퍼 모드
### 인증 메커니즘
#### CA 발급 과정 
### 암호화 알고리즘
#### 디피-헬만 키 교환 암호화 알고리즘 
### 해싱 알고리즘 
#### SHA-256 알고리즘
## SEO에도 도움이 되는 HTTPS 
### 캐노니컬 설정
### 메타 설정
### 페이지 속도 개선
### 사이트맵 관리
## HTTPS 구축 방법
# HTTP/3
## 초기 연결 설정 시 지연 시간 감소
