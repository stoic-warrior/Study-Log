# 생성 패턴 (Creational Patterns)
## Singleton Pattern
> 인스턴스 하나만 존재 보장 
### What (무엇인가)
- 클래스의 인스턴스가 프로그램 전체에서 단 하나만 존재하도록 보장하는 패턴
### Why (왜 사용하는가)
- 데이터베이스 연결, 설정 관리자처럼 전역적으로 하나만 있어야 하는 객체를 관리할 때
- 메모리 절약과 일관된 상태 유지가 필요할 때
- Spring Bean의 기본 스코프가 싱글톤인 이유도 동일합니다
### How (어떻게 구현하는가)
#### 예시1
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
#### 예시2
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
## Factory Pattern
> 생성 책임을 객체 밖으로 분리 (결합도↓)
### What (무엇인가)
- 객체 생성 로직을 별도의 팩토리 클래스로 분리하여, 클라이언트는 구체적인 클래스를 모르고도 객체를 생성할 수 있게 하는 패턴입니다.
### Why (왜 사용하는가)
- 객체 생성 로직이 복잡하거나 조건에 따라 다른 객체를 생성해야 할 때
- 새로운 타입 추가 시 클라이언트 코드 수정을 최소화하기 위해
- 의존성을 인터페이스에만 두어 결합도를 낮추기 위해
### How (어떻게 구현하는가)
```
// 제품 인터페이스
public interface Notification {
    void send(String message);
}

// 구체적인 제품들
public class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

public class SmsNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}

// 팩토리
public class NotificationFactory {
    public Notification createNotification(String type) {
        return switch(type.toUpperCase()) {
            case "EMAIL" -> new EmailNotification();
            case "SMS" -> new SmsNotification();
            case "PUSH" -> new PushNotification();
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}

// 사용
NotificationFactory factory = new NotificationFactory();
Notification notification = factory.createNotification("EMAIL");
notification.send("Hello!");
```
```
public interface Payment {
    void processPayment(double amount);
}

public class PaymentFactory {
    public Payment createPayment(String type) {
        return switch(type) {
            case "CARD" -> new CardPayment();
            case "BANK" -> new BankTransferPayment();
            default -> throw new IllegalArgumentException();
        };
    }
}
```
## Builder Pattern
> 복잡 객체를 단계적으로 조립
### What (무엇인가)
- 복잡한 객체를 단계별로 생성할 수 있게 하며, 동일한 생성 절차로 다양한 표현을 만들 수 있는 패턴입니다.
### Why (왜 사용하는가)
- 생성자 파라미터가 많아서 가독성이 떨어질 때
- 선택적 파라미터가 많을 때 (telescoping constructor 문제 해결)
- 불변 객체를 만들면서도 유연하게 생성하고 싶을 때
### How (어떻게 구현하는가)
```
public class User {
    // 필수 필드
    private final String email;
    private final String password;
    
    // 선택적 필드
    private final String name;
    private final int age;
    private final String phoneNumber;
    private final String address;
    
    private User(Builder builder) {
        this.email = builder.email;
        this.password = builder.password;
        this.name = builder.name;
        this.age = builder.age;
        this.phoneNumber = builder.phoneNumber;
        this.address = builder.address;
    }
    
    public static class Builder {
        // 필수
        private final String email;
        private final String password;
        
        // 선택
        private String name;
        private int age;
        private String phoneNumber;
        private String address;
        
        public Builder(String email, String password) {
            this.email = email;
            this.password = password;
        }
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder phoneNumber(String phoneNumber) {
            this.phoneNumber = phoneNumber;
            return this;
        }
        
        public Builder address(String address) {
            this.address = address;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// 사용
User user = new User.Builder("user@example.com", "password123")
    .name("홍길동")
    .age(30)
    .phoneNumber("010-1234-5678")
    .build();

// Lombok 사용 시
@Builder
public class User {
    private String email;
    private String password;
    private String name;
    private int age;
}
```
# 구조 패턴 (Structural Patterns)
## Adapter Pattern
> 인터페이스 불일치 해소
## What (무엇인가)
- 호환되지 않는 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 중간에서 변환해주는 패턴입니다.
## Why (왜 사용하는가)
- 기존 코드를 수정하지 않고 새로운 인터페이스와 통합할 때
- 레거시 시스템과 새 시스템을 연결할 때
- 외부 라이브러리를 프로젝트 표준에 맞게 래핑할 때
## How (어떻게 구현하는가)
```
// 새로운 표준 인터페이스
public interface PaymentProcessor {
    PaymentResult process(PaymentRequest request);
}

// 레거시 시스템
public class LegacyPaymentSystem {
    public boolean makePayment(String cardNumber, double amount, String currency) {
        // 기존 결제 로직
        System.out.println("Legacy payment: " + amount + " " + currency);
        return true;
    }
}

// 어댑터
public class LegacyPaymentAdapter implements PaymentProcessor {
    private LegacyPaymentSystem legacySystem;
    
    public LegacyPaymentAdapter() {
        this.legacySystem = new LegacyPaymentSystem();
    }
    
    @Override
    public PaymentResult process(PaymentRequest request) {
        // 새로운 형식을 레거시 형식으로 변환
        boolean success = legacySystem.makePayment(
            request.getCardNumber(),
            request.getAmount(),
            request.getCurrency()
        );
        
        return new PaymentResult(success, "Payment processed");
    }
}

// 사용
PaymentProcessor processor = new LegacyPaymentAdapter();
PaymentResult result = processor.process(new PaymentRequest(...));
```
## Proxy Pattern
> 객체 접근을 대신 수행·통제
## What (무엇인가)
- 실제 객체에 대한 대리자(Proxy)를 제공하여, 실제 객체에 대한 접근을 제어하는 패턴입니다.
## Why (왜 사용하는가)
- 실제 객체 접근 전후에 부가 기능을 추가할 때 (로깅, 권한 체크, 캐싱)
- 지연 로딩(Lazy Loading)을 구현할 때
- 원격 객체에 대한 로컬 대리자가 필요할 때
- Spring AOP가 이 패턴으로 구현됩니다
## How (어떻게 구현하는가)
```
// 공통 인터페이스
public interface ImageService {
    void display();
}

// 실제 객체 (비용이 큰 작업)
public class RealImageService implements ImageService {
    private String filename;
    
    public RealImageService(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    
    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
        // 시간이 오래 걸리는 작업
    }
    
    public void display() {
        System.out.println("Displaying: " + filename);
    }
}

// 프록시 (지연 로딩 + 캐싱)
public class ImageServiceProxy implements ImageService {
    private RealImageService realImageService;
    private String filename;
    private boolean isLoaded = false;
    
    public ImageServiceProxy(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        // 실제 필요할 때만 로딩
        if (!isLoaded) {
            realImageService = new RealImageService(filename);
            isLoaded = true;
        }
        
        // 권한 체크
        if (hasPermission()) {
            realImageService.display();
        } else {
            System.out.println("Access denied");
        }
    }
    
    private boolean hasPermission() {
        // 권한 체크 로직
        return true;
    }
}

// 사용
ImageService image = new ImageServiceProxy("large_image.jpg");
// 여기서는 아직 로딩되지 않음
image.display(); // 이 시점에 실제 로딩
```
```
public interface UserService {
    User getUser(Long id);
}

public class UserServiceProxy implements UserService {
    private UserService realService;
    
    public User getUser(Long id) {
        // 권한 체크, 로깅, 캐싱 등
        logAccess(id);
        return realService.getUser(id);
    }
}
```
## Decorator Pattern
> 기존 객체를 감싸서 새로운 기능을 동적으로 추가
## What (무엇인가)
- 객체에 동적으로 새로운 책임(기능)을 추가할 수 있게 하는 패턴입니다. 상속의 대안으로 사용됩니다.
## Why (왜 사용하는가)
- 기존 코드를 수정하지 않고 기능을 추가할 때
- 런타임에 동적으로 기능을 조합할 때
- 상속으로 인한 클래스 폭발을 방지할 때
- Java의 I/O 스트림이 대표적인 예입니다
## How (어떻게 구현하는가)
```
// 기본 인터페이스
public interface Coffee {
    String getDescription();
    double getCost();
}

// 기본 구현
public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

// 데코레이터 추상 클래스
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
}

// 구체적인 데코레이터들
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Milk";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Sugar";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.2;
    }
}

// 사용 - 기능을 동적으로 조합
Coffee coffee = new SimpleCoffee();
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new MilkDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// 출력: Simple Coffee, Milk, Sugar $2.7
```
```
public interface Coffee {
    double getCost();
    String getDescription();
}

public class MilkDecorator implements Coffee {
    private Coffee coffee;
    
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}
```
# 행위 패턴 (Behavioral Patterns)
## Strategy Pattern
> 알고리즘을 런타임에 교체 가능하게 캡슐화
### What (무엇인가)
- 알고리즘 군을 정의하고 각각을 캡슐화하여 교환 가능하게 만드는 패턴입니다.
### Why (왜 사용하는가)
- 조건문(if-else, switch)이 많아질 때 이를 대체하기 위해
- 런타임에 알고리즘을 선택하고 변경해야 할 때
- 알고리즘의 변형이 많고 자주 변경될 때
### How (어떻게 구현하는가)
```
// 전략 인터페이스
public interface PaymentStrategy {
    boolean pay(double amount);
}

// 구체적인 전략들
public class CreditCardStrategy implements PaymentStrategy {
    private String cardNumber;
    private String cvv;
    
    public CreditCardStrategy(String cardNumber, String cvv) {
        this.cardNumber = cardNumber;
        this.cvv = cvv;
    }
    
    @Override
    public boolean pay(double amount) {
        System.out.println("Paid " + amount + " using Credit Card");
        return true;
    }
}

public class KakaoPayStrategy implements PaymentStrategy {
    private String email;
    
    public KakaoPayStrategy(String email) {
        this.email = email;
    }
    
    @Override
    public boolean pay(double amount) {
        System.out.println("Paid " + amount + " using KakaoPay");
        return true;
    }
}

// 컨텍스트
public class ShoppingCart {
    private List<Item> items = new ArrayList<>();
    private PaymentStrategy paymentStrategy;
    
    public void setPaymentStrategy(PaymentStrategy strategy) {
        this.paymentStrategy = strategy;
    }
    
    public void checkout() {
        double total = calculateTotal();
        paymentStrategy.pay(total);
    }
    
    private double calculateTotal() {
        return items.stream()
            .mapToDouble(Item::getPrice)
            .sum();
    }
}

// 사용
ShoppingCart cart = new ShoppingCart();
cart.addItem(new Item("Laptop", 1500));

// 결제 방법을 런타임에 선택
cart.setPaymentStrategy(new CreditCardStrategy("1234-5678", "123"));
cart.checkout();

// 다른 방법으로 변경
cart.setPaymentStrategy(new KakaoPayStrategy("user@example.com"));
cart.checkout();
```
```
public interface DiscountStrategy {
    double applyDiscount(double price);
}

public class SeasonalDiscount implements DiscountStrategy {
    public double applyDiscount(double price) {
        return price * 0.9;
    }
}

public class ShoppingCart {
    private DiscountStrategy strategy;
    
    public double calculateTotal(double price) {
        return strategy.applyDiscount(price);
    }
}
```
## Template Method Pattern
> 알고리즘의 뼈대를 정의하고 세부 구현은 하위로 위임
## What (무엇인가)
- 알고리즘의 구조를 정의하고, 일부 단계를 서브클래스에서 구현하도록 하는 패턴입니다.
## Why (왜 사용하는가)
- 알고리즘의 전체 구조는 동일하지만 특정 단계만 달라질 때
- 코드 중복을 제거하고 공통 로직을 재사용할 때
- 프레임워크에서 확장 포인트를 제공할 때 (예: Spring의 JdbcTemplate)
## How (어떻게 구현하는가)
```
// 템플릿 메소드를 가진 추상 클래스
public abstract class DataMiner {
    
    // 템플릿 메소드 - 알고리즘의 골격
    public final void mine(String path) {
        openFile(path);
        extractData();
        parseData();
        analyzeData();
        sendReport();
        closeFile();
    }
    
    // 공통 메소드
    private void openFile(String path) {
        System.out.println("Opening file: " + path);
    }
    
    private void closeFile() {
        System.out.println("Closing file");
    }
    
    // 추상 메소드 - 서브클래스에서 구현
    protected abstract void extractData();
    protected abstract void parseData();
    
    // 훅 메소드 - 선택적 오버라이드
    protected void analyzeData() {
        // 기본 구현
    }
    
    protected void sendReport() {
        System.out.println("Sending report");
    }
}

// 구체적인 구현
public class CSVDataMiner extends DataMiner {
    @Override
    protected void extractData() {
        System.out.println("Extracting CSV data");
    }
    
    @Override
    protected void parseData() {
        System.out.println("Parsing CSV data");
    }
}

public class JSONDataMiner extends DataMiner {
    @Override
    protected void extractData() {
        System.out.println("Extracting JSON data");
    }
    
    @Override
    protected void parseData() {
        System.out.println("Parsing JSON data");
    }
    
    @Override
    protected void analyzeData() {
        System.out.println("Analyzing JSON structure");
    }
}

// 사용
DataMiner csvMiner = new CSVDataMiner();
csvMiner.mine("data.csv");

DataMiner jsonMiner = new JSONDataMiner();
jsonMiner.mine("data.json");
```
```
public abstract class DataProcessor {
    public final void process() {
        readData();
        processData();
        saveData();
    }
    
    abstract void readData();
    abstract void processData();
    abstract void saveData();
}
```
## Observer Pattern
> 객체 상태 변화를 구독자들에게 자동으로 전파
### What (무엇인가)
- 객체 사이의 일대다 의존 관계를 정의하여, 한 객체의 상태가 변경되면 그 객체에 의존하는 다른 객체들이 자동으로 통지받고 업데이트되는 패턴입니다.
### Why (왜 사용하는가)
- 객체 간의 결합도를 낮추면서 상태 변화를 알려야 할 때
- 이벤트 기반 시스템을 구현할 때
- Spring의 ApplicationEvent, Message Queue 시스템의 기반이 됩니다
### How (어떻게 구현하는가)
```
// 관찰자 인터페이스
public interface OrderObserver {
    void update(Order order);
}

// 구체적인 관찰자들
public class EmailNotificationObserver implements OrderObserver {
    @Override
    public void update(Order order) {
        System.out.println("Sending email for order: " + order.getId());
        // 이메일 발송 로직
    }
}

public class InventoryObserver implements OrderObserver {
    @Override
    public void update(Order order) {
        System.out.println("Updating inventory for order: " + order.getId());
        // 재고 업데이트 로직
    }
}

public class SMSNotificationObserver implements OrderObserver {
    @Override
    public void update(Order order) {
        System.out.println("Sending SMS for order: " + order.getId());
    }
}

// 주체 (Subject)
public class OrderService {
    private List<OrderObserver> observers = new ArrayList<>();
    
    public void addObserver(OrderObserver observer) {
        observers.add(observer);
    }
    
    public void removeObserver(OrderObserver observer) {
        observers.remove(observer);
    }
    
    public void createOrder(Order order) {
        // 주문 생성 로직
        System.out.println("Order created: " + order.getId());
        
        // 모든 관찰자에게 통지
        notifyObservers(order);
    }
    
    private void notifyObservers(Order order) {
        for (OrderObserver observer : observers) {
            observer.update(order);
        }
    }
}

// 사용
OrderService orderService = new OrderService();

// 관찰자 등록
orderService.addObserver(new EmailNotificationObserver());
orderService.addObserver(new InventoryObserver());
orderService.addObserver(new SMSNotificationObserver());

// 주문 생성 시 모든 관찰자에게 자동 통지
orderService.createOrder(new Order("ORD-001"));

// Spring의 ApplicationEvent 사용 예
@Component
public class OrderEventListener {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 이벤트 처리
    }
}
```
```
public class OrderService {
    private List<OrderObserver> observers = new ArrayList<>();
    
    public void placeOrder(Order order) {
        // 주문 처리
        notifyObservers(order);
    }
    
    private void notifyObservers(Order order) {
        observers.forEach(o -> o.onOrderPlaced(order));
    }
}
```
## Chain of Responsibility
>  요청을 체인으로 순차 처리
## What (무엇인가)
- 요청을 처리할 수 있는 객체들의 체인을 만들어, 요청이 처리될 때까지 체인을 따라 전달하는 패턴입니다.
## Why (왜 사용하는가)
- 여러 객체가 요청을 처리할 수 있지만, 어떤 객체가 처리할지 미리 알 수 없을 때
- 요청 처리의 순서를 동적으로 지정하고 싶을 때
- Spring Security의 Filter Chain이 대표적인 예입니다
## How (어떻게 구현하는가)
```
// 핸들러 추상 클래스
public abstract class SupportHandler {
    protected SupportHandler nextHandler;
    
    public void setNextHandler(SupportHandler handler) {
        this.nextHandler = handler;
    }
    
    public abstract void handleRequest(SupportTicket ticket);
}

// 구체적인 핸들러들
public class Level1SupportHandler extends SupportHandler {
    @Override
    public void handleRequest(SupportTicket ticket) {
        if (ticket.getPriority() == Priority.LOW) {
            System.out.println("Level 1: Handling ticket " + ticket.getId());
            ticket.resolve();
        } else if (nextHandler != null) {
            System.out.println("Level 1: Escalating ticket " + ticket.getId());
            nextHandler.handleRequest(ticket);
        }
    }
}

public class Level2SupportHandler extends SupportHandler {
    @Override
    public void handleRequest(SupportTicket ticket) {
        if (ticket.getPriority() == Priority.MEDIUM) {
            System.out.println("Level 2: Handling ticket " + ticket.getId());
            ticket.resolve();
        } else if (nextHandler != null) {
            System.out.println("Level 2: Escalating ticket " + ticket.getId());
            nextHandler.handleRequest(ticket);
        }
    }
}

public class Level3SupportHandler extends SupportHandler {
    @Override
    public void handleRequest(SupportTicket ticket) {
        System.out.println("Level 3: Handling critical ticket " + ticket.getId());
        ticket.resolve();
    }
}

// 사용
SupportHandler level1 = new Level1SupportHandler();
SupportHandler level2 = new Level2SupportHandler();
SupportHandler level3 = new Level3SupportHandler();

// 체인 구성
level1.setNextHandler(level2);
level2.setNextHandler(level3);

// 요청 처리
SupportTicket ticket1 = new SupportTicket("T001", Priority.LOW);
level1.handleRequest(ticket1);  // Level 1에서 처리

SupportTicket ticket2 = new SupportTicket("T002", Priority.HIGH);
level1.handleRequest(ticket2);  // Level 3까지 전달되어 처리

// Spring Security Filter Chain 예시
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        return http
            .addFilterBefore(new CustomAuthFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilterAfter(new LoggingFilter(), BasicAuthenticationFilter.class)
            .build();
    }
}
```
```
public abstract class RequestHandler {
    protected RequestHandler next;
    
    public void setNext(RequestHandler handler) {
        this.next = handler;
    }
    
    public abstract void handle(Request request);
}

public class AuthenticationHandler extends RequestHandler {
    public void handle(Request request) {
        if (isAuthenticated(request)) {
            next.handle(request);
        }
    }
}
```
