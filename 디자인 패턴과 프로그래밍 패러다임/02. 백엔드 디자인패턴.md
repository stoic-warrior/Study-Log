# 생성 패턴 (Creational Patterns)
## Singleton Pattern
> 인스턴스 하나만 존재 보장 
### What (무엇인가)
- 클래스의 인스턴스가 프로그램 전체에서 단 하나만 존재하도록 보장하는 패턴
### Why (왜 사용하는가)
- 데이터베이스 연결, 설정 관리자처럼 전역적으로 하나만 있어야 하는 객체를 관리할 때
- 메모리 절약과 일관된 상태 유지가 필요할 때
- Spring Bean의 기본 스코프가 싱글톤인 이유도 동일합니다
### How (어떻게 구현하는가)
#### 예시1
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
#### 예시2
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
## Factory Pattern
> 생성 책임을 객체 밖으로 분리 (결합도↓)
### What (무엇인가)
- 객체 생성 로직을 별도의 팩토리 클래스로 분리하여, 클라이언트는 구체적인 클래스를 모르고도 객체를 생성할 수 있게 하는 패턴입니다.
### Why (왜 사용하는가)
- 객체 생성 로직이 복잡하거나 조건에 따라 다른 객체를 생성해야 할 때
- 새로운 타입 추가 시 클라이언트 코드 수정을 최소화하기 위해
- 의존성을 인터페이스에만 두어 결합도를 낮추기 위해
### How (어떻게 구현하는가)
```
// 제품 인터페이스
public interface Notification {
    void send(String message);
}

// 구체적인 제품들
public class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

public class SmsNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}

// 팩토리
public class NotificationFactory {
    public Notification createNotification(String type) {
        return switch(type.toUpperCase()) {
            case "EMAIL" -> new EmailNotification();
            case "SMS" -> new SmsNotification();
            case "PUSH" -> new PushNotification();
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}

// 사용
NotificationFactory factory = new NotificationFactory();
Notification notification = factory.createNotification("EMAIL");
notification.send("Hello!");
```
```
public interface Payment {
    void processPayment(double amount);
}

public class PaymentFactory {
    public Payment createPayment(String type) {
        return switch(type) {
            case "CARD" -> new CardPayment();
            case "BANK" -> new BankTransferPayment();
            default -> throw new IllegalArgumentException();
        };
    }
}
```
## Builder Pattern
> 복잡 객체를 단계적으로 조립
### What (무엇인가)
- 복잡한 객체를 단계별로 생성할 수 있게 하며, 동일한 생성 절차로 다양한 표현을 만들 수 있는 패턴입니다.
### Why (왜 사용하는가)
- 생성자 파라미터가 많아서 가독성이 떨어질 때
- 선택적 파라미터가 많을 때 (telescoping constructor 문제 해결)
- 불변 객체를 만들면서도 유연하게 생성하고 싶을 때
### How (어떻게 구현하는가)
```
public class User {
    // 필수 필드
    private final String email;
    private final String password;
    
    // 선택적 필드
    private final String name;
    private final int age;
    private final String phoneNumber;
    private final String address;
    
    private User(Builder builder) {
        this.email = builder.email;
        this.password = builder.password;
        this.name = builder.name;
        this.age = builder.age;
        this.phoneNumber = builder.phoneNumber;
        this.address = builder.address;
    }
    
    public static class Builder {
        // 필수
        private final String email;
        private final String password;
        
        // 선택
        private String name;
        private int age;
        private String phoneNumber;
        private String address;
        
        public Builder(String email, String password) {
            this.email = email;
            this.password = password;
        }
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        
        public Builder phoneNumber(String phoneNumber) {
            this.phoneNumber = phoneNumber;
            return this;
        }
        
        public Builder address(String address) {
            this.address = address;
            return this;
        }
        
        public User build() {
            return new User(this);
        }
    }
}

// 사용
User user = new User.Builder("user@example.com", "password123")
    .name("홍길동")
    .age(30)
    .phoneNumber("010-1234-5678")
    .build();

// Lombok 사용 시
@Builder
public class User {
    private String email;
    private String password;
    private String name;
    private int age;
}
```
# 구조 패턴 (Structural Patterns)
## Adapter Pattern
> 인터페이스 불일치 해소
## What (무엇인가)
- 호환되지 않는 인터페이스를 가진 클래스들이 함께 동작할 수 있도록 중간에서 변환해주는 패턴입니다.
## Why (왜 사용하는가)
- 기존 코드를 수정하지 않고 새로운 인터페이스와 통합할 때
- 레거시 시스템과 새 시스템을 연결할 때
- 외부 라이브러리를 프로젝트 표준에 맞게 래핑할 때
## How (어떻게 구현하는가)
```
// 새로운 표준 인터페이스
public interface PaymentProcessor {
    PaymentResult process(PaymentRequest request);
}

// 레거시 시스템
public class LegacyPaymentSystem {
    public boolean makePayment(String cardNumber, double amount, String currency) {
        // 기존 결제 로직
        System.out.println("Legacy payment: " + amount + " " + currency);
        return true;
    }
}

// 어댑터
public class LegacyPaymentAdapter implements PaymentProcessor {
    private LegacyPaymentSystem legacySystem;
    
    public LegacyPaymentAdapter() {
        this.legacySystem = new LegacyPaymentSystem();
    }
    
    @Override
    public PaymentResult process(PaymentRequest request) {
        // 새로운 형식을 레거시 형식으로 변환
        boolean success = legacySystem.makePayment(
            request.getCardNumber(),
            request.getAmount(),
            request.getCurrency()
        );
        
        return new PaymentResult(success, "Payment processed");
    }
}

// 사용
PaymentProcessor processor = new LegacyPaymentAdapter();
PaymentResult result = processor.process(new PaymentRequest(...));
```
## Proxy Pattern
> 객체 접근을 대신 수행·통제
## What (무엇인가)
- 실제 객체에 대한 대리자(Proxy)를 제공하여, 실제 객체에 대한 접근을 제어하는 패턴입니다.
## Why (왜 사용하는가)
- 실제 객체 접근 전후에 부가 기능을 추가할 때 (로깅, 권한 체크, 캐싱)
- 지연 로딩(Lazy Loading)을 구현할 때
- 원격 객체에 대한 로컬 대리자가 필요할 때
- Spring AOP가 이 패턴으로 구현됩니다
## How (어떻게 구현하는가)
```
// 공통 인터페이스
public interface ImageService {
    void display();
}

// 실제 객체 (비용이 큰 작업)
public class RealImageService implements ImageService {
    private String filename;
    
    public RealImageService(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    
    private void loadFromDisk() {
        System.out.println("Loading image: " + filename);
        // 시간이 오래 걸리는 작업
    }
    
    public void display() {
        System.out.println("Displaying: " + filename);
    }
}

// 프록시 (지연 로딩 + 캐싱)
public class ImageServiceProxy implements ImageService {
    private RealImageService realImageService;
    private String filename;
    private boolean isLoaded = false;
    
    public ImageServiceProxy(String filename) {
        this.filename = filename;
    }
    
    @Override
    public void display() {
        // 실제 필요할 때만 로딩
        if (!isLoaded) {
            realImageService = new RealImageService(filename);
            isLoaded = true;
        }
        
        // 권한 체크
        if (hasPermission()) {
            realImageService.display();
        } else {
            System.out.println("Access denied");
        }
    }
    
    private boolean hasPermission() {
        // 권한 체크 로직
        return true;
    }
}

// 사용
ImageService image = new ImageServiceProxy("large_image.jpg");
// 여기서는 아직 로딩되지 않음
image.display(); // 이 시점에 실제 로딩
```
```
public interface UserService {
    User getUser(Long id);
}

public class UserServiceProxy implements UserService {
    private UserService realService;
    
    public User getUser(Long id) {
        // 권한 체크, 로깅, 캐싱 등
        logAccess(id);
        return realService.getUser(id);
    }
}
```
## Decorator Pattern
> 기존 객체를 감싸서 새로운 기능을 동적으로 추가
## What (무엇인가)
- 객체에 동적으로 새로운 책임(기능)을 추가할 수 있게 하는 패턴입니다. 상속의 대안으로 사용됩니다.
## Why (왜 사용하는가)
- 기존 코드를 수정하지 않고 기능을 추가할 때
- 런타임에 동적으로 기능을 조합할 때
- 상속으로 인한 클래스 폭발을 방지할 때
- Java의 I/O 스트림이 대표적인 예입니다
## How (어떻게 구현하는가)
```
// 기본 인터페이스
public interface Coffee {
    String getDescription();
    double getCost();
}

// 기본 구현
public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 2.0;
    }
}

// 데코레이터 추상 클래스
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
}

// 구체적인 데코레이터들
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Milk";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.5;
    }
}

public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription() + ", Sugar";
    }
    
    @Override
    public double getCost() {
        return decoratedCoffee.getCost() + 0.2;
    }
}

// 사용 - 기능을 동적으로 조합
Coffee coffee = new SimpleCoffee();
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new MilkDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());

coffee = new SugarDecorator(coffee);
System.out.println(coffee.getDescription() + " $" + coffee.getCost());
// 출력: Simple Coffee, Milk, Sugar $2.7
```
```
public interface Coffee {
    double getCost();
    String getDescription();
}

public class MilkDecorator implements Coffee {
    private Coffee coffee;
    
    public double getCost() {
        return coffee.getCost() + 0.5;
    }
}
```
