# 생성 패턴 (Creational Patterns)
## Singleton Pattern
> 인스턴스 하나만 존재 보장 
### What (무엇인가)
- 클래스의 인스턴스가 프로그램 전체에서 단 하나만 존재하도록 보장하는 패턴
### Why (왜 사용하는가)
- 데이터베이스 연결, 설정 관리자처럼 전역적으로 하나만 있어야 하는 객체를 관리할 때
- 메모리 절약과 일관된 상태 유지가 필요할 때
- Spring Bean의 기본 스코프가 싱글톤인 이유도 동일합니다
### How (어떻게 구현하는가)
#### 예시1
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
#### 예시2
```
// Thread-safe한 싱글톤 (Bill Pugh 방식)
public class ConfigManager {
    private ConfigManager() {
        // 외부 생성 방지
    }
    
    private static class SingletonHelper {
        private static final ConfigManager INSTANCE = new ConfigManager();
    }
    
    public static ConfigManager getInstance() {
        return SingletonHelper.INSTANCE;
    }
    
    public String getProperty(String key) {
        return properties.get(key);
    }
}

// 사용
ConfigManager config = ConfigManager.getInstance();
```
## Factory Pattern
> 생성 책임을 객체 밖으로 분리 (결합도↓)
### What (무엇인가)
- 객체 생성 로직을 별도의 팩토리 클래스로 분리하여, 클라이언트는 구체적인 클래스를 모르고도 객체를 생성할 수 있게 하는 패턴입니다.
### Why (왜 사용하는가)
- 객체 생성 로직이 복잡하거나 조건에 따라 다른 객체를 생성해야 할 때
- 새로운 타입 추가 시 클라이언트 코드 수정을 최소화하기 위해
- 의존성을 인터페이스에만 두어 결합도를 낮추기 위해
### How (어떻게 구현하는가)
```
// 제품 인터페이스
public interface Notification {
    void send(String message);
}

// 구체적인 제품들
public class EmailNotification implements Notification {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

public class SmsNotification implements Notification {
    public void send(String message) {
        System.out.println("SMS: " + message);
    }
}

// 팩토리
public class NotificationFactory {
    public Notification createNotification(String type) {
        return switch(type.toUpperCase()) {
            case "EMAIL" -> new EmailNotification();
            case "SMS" -> new SmsNotification();
            case "PUSH" -> new PushNotification();
            default -> throw new IllegalArgumentException("Unknown type: " + type);
        };
    }
}

// 사용
NotificationFactory factory = new NotificationFactory();
Notification notification = factory.createNotification("EMAIL");
notification.send("Hello!");
````
## Builder Pattern
> 복잡 객체를 단계적으로
### What (무엇인가)
복잡한 객체를 단계별로 생성할 수 있게 하며, 동일한 생성 절차로 다양한 표현을 만들 수 있는 패턴입니다.
### Why (왜 사용하는가)

생성자 파라미터가 많아서 가독성이 떨어질 때
선택적 파라미터가 많을 때 (telescoping constructor 문제 해결)
불변 객체를 만들면서도 유연하게 생성하고 싶을 때

### How (어떻게 구현하는가)


