# 프로그래밍 패러다임
> 프로그램을 바라보는 ‘철학’과 ‘방법론’
- 프로그래밍의 관점을 제공
  - “데이터를 중심으로 볼 것인가?”
  - “행위를 중심으로 볼 것인가?”
  - “상태를 허용할 것인가, 배제할 것인가?”
<img width="503" height="239" alt="image" src="https://github.com/user-attachments/assets/50f0e7ee-ed18-4de3-9df3-24e059d1efa8" />

# 선언형 프로그래밍 (Declarative Programming)
> What에 집중하고, How는 시스템에 맡긴다
- 결과에 집중
- 내부 동작을 직접 제어하지 않음
## ex
- SQL: `SELECT * FROM user WHERE age > 20`
- **무엇을 할지 (결과)**
  - “user 테이블에서”
  - “나이가 20보다 큰 것만”
  - “가져와라”
- **어떻게 할지 (방법)** 
  - 몇 번째 행부터 읽을지
  - 인덱스를 쓸지
  - 정렬을 먼저 할지
  - 반복문을 돌지 말지
  - 👉 DB가 알아서 결정함
# 함수형 프로그래밍
> 불변 데이터와 순수 함수를 최대한 활용 
- 함수를 값처럼 다룸
- 상태 변경을 최소화 → 예측 가능성 ↑
## 순수 함수
> 출력이 입력에만 의존
- 같은 입력 → 항상 같은 출력
- 외부 상태 변경 ❌
```
// 순수 함수 예시
public class PureFunction {
    // 순수 함수 - 항상 같은 입력에 같은 출력, 부작용 없음
    public static int add(int a, int b) {
        return a + b;
    }
    
    // 순수하지 않은 함수 - 외부 상태에 의존
    private static int counter = 0;
    public static int incrementCounter() {
        return ++counter; // 외부 상태 변경
    }
}
```
## 고차 함수
> 함수를 인자로 받거나 반환하는 함수
- 고차 함수를 쓰려면 해당 언어가 **일급 객체**여야 한다
```
list.stream().filter(x -> x > 10);
```
### 일급 객체
> 변수 할당, 전달, 반환이 가능한 객체
- 함수가 다음을 만족하면 일급 객체:
  - 변수에 할당 가능
  - 인자로 전달 가능
  - 반환값으로 사용 가능
- 👉 고차 함수가 가능한 이유 = 함수가 일급 객체이기 때
# 객체지향 프로그래밍
> 상태와 행위를 가진 객체들의 상호작용
- 설계에 많은 시간 소요, 처리 속도도 상대적으로 느
## 객체지향  프로그래밍의 특징
### 추상화
> 핵심만 추출, 세부사항 숨김 
- 공통 핵심만 뽑아냄
- 인터페이스, 추상 클래스
```
interface Payment {
    void pay();
}
```
### 캡슐화
> 데이터와 메서드를 묶어 외부 접근 제한
- 내부 구현 은닉
- 접근 제어자로 보호
- 👉 변경에 강해짐
```
private int balance;
```
### 상속성
> 상위 클래스 특성을 하위가 물려받음 
- 기존 클래스를 재사용
- 하지만 남용하면 결합도 폭증
```
class CardPayment extends Payment { }
```
### 다형성
> 같은 인터페이스로 여러 구현을 처리
- ex) Animal이라는 타입으로 Cat, Dog등을 처리할 수 있으며, sound()라는 메서드도 각각 다른 동작을 하게 된다
```
class Shape {
    public double getArea() {
        return 0;
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
}

// 다형성 활용
public class PolymorphismDemo {
    public static void printArea(Shape shape) {
        System.out.println("면적: " + shape.getArea());
    }
    
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape rectangle = new Rectangle(4, 6);
        
        printArea(circle);    // 원의 면적
        printArea(rectangle); // 사각형의 면적
    }
}
```
#### 오버로딩
> 같은 이름, 다른 매개변수로 메서드 중복 정
- 컴파일 타임 ("어떤 메서드 시그니처를 찾을지" 결정)
#### 오버라이딩
> 상속받은 메서드를 하위에서 재정의 
- 런타임 (실행시점에 어떤 객체가 연결되어 있을지 미리 모르기 때문)
## 객체지향 설계 원칙 (SOLID)
> 유지보수 가능한 코드를 만드는 규율
### 단일 책임 원칙 (SRP)
> 하나의 클래스는 하나의 책임만
### 개방-폐쇄 원칙 (OCP)
> 확장에는 열려있고, 수정에는 닫혀있음
- 👉 전략 패턴의 근거
### 라스코프 치환 원칙
### 인터페이스 분리 원칙
### 의존 역전 원칙
# 절차형 프로그래밍
# 패러다임의 혼합
