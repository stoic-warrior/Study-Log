# 프로그래밍 패러다임
> 프로그램을 바라보는 ‘철학’과 ‘방법론’
- 프로그래밍의 관점을 제공
  - “데이터를 중심으로 볼 것인가?”
  - “행위를 중심으로 볼 것인가?”
  - “상태를 허용할 것인가, 배제할 것인가?”
<img width="503" height="239" alt="image" src="https://github.com/user-attachments/assets/50f0e7ee-ed18-4de3-9df3-24e059d1efa8" />

# 선언형 프로그래밍 (Declarative Programming)
> What에 집중하고, How는 시스템에 맡긴다
- 결과에 집중
- 내부 동작을 직접 제어하지 않음
## ex
- SQL: `SELECT * FROM user WHERE age > 20`
- **무엇을 할지 (결과)**
  - “user 테이블에서”
  - “나이가 20보다 큰 것만”
  - “가져와라”
- **어떻게 할지 (방법)** 
  - 몇 번째 행부터 읽을지
  - 인덱스를 쓸지
  - 정렬을 먼저 할지
  - 반복문을 돌지 말지
  - 👉 DB가 알아서 결정함
# 함수형 프로그래밍
> 불변 데이터와 순수 함수를 최대한 활용 
- 함수를 값처럼 다룸
- 상태 변경을 최소화 → 예측 가능성 ↑
## 순수 함수
> 출력이 입력에만 의존
- 같은 입력 → 항상 같은 출력
- 외부 상태 변경 ❌
```
// 순수 함수 예시
public class PureFunction {
    // 순수 함수 - 항상 같은 입력에 같은 출력, 부작용 없음
    public static int add(int a, int b) {
        return a + b;
    }
    
    // 순수하지 않은 함수 - 외부 상태에 의존
    private static int counter = 0;
    public static int incrementCounter() {
        return ++counter; // 외부 상태 변경
    }
}
```
## 고차 함수
> 함수를 인자로 받거나 반환하는 함수
- 고차 함수를 쓰려면 해당 언어가 **일급 객체**여야 한다
```
list.stream().filter(x -> x > 10);
```
### 일급 객체
> 변수 할당, 전달, 반환이 가능한 객체
- 함수가 다음을 만족하면 일급 객체:
  - 변수에 할당 가능
  - 인자로 전달 가능
  - 반환값으로 사용 가능
- 👉 고차 함수가 가능한 이유 = 함수가 일급 객체이기 때
# 객체지향 프로그래밍
> 상태와 행위를 가진 객체들의 상호작용
- 설계에 많은 시간 소요, 처리 속도도 상대적으로 느
## 객체지향  프로그래밍의 특징
### 추상화
> 핵심만 추출, 세부사항 숨김 
- 공통 핵심만 뽑아냄
- 인터페이스, 추상 클래스
```
interface Payment {
    void pay();
}
```
### 캡슐화
> 데이터와 메서드를 묶어 외부 접근 제한
- 내부 구현 은닉
- 접근 제어자로 보호
- 👉 변경에 강해짐
```
private int balance;
```
### 상속성
> 상위 클래스 특성을 하위가 물려받음 
- 기존 클래스를 재사용
- 하지만 남용하면 결합도 폭증
```
class CardPayment extends Payment { }
```
### 다형성
> 같은 인터페이스로 여러 구현을 처리
- ex) Animal이라는 타입으로 Cat, Dog등을 처리할 수 있으며, sound()라는 메서드도 각각 다른 동작을 하게 된다
```
class Shape {
    public double getArea() {
        return 0;
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
}

// 다형성 활용
public class PolymorphismDemo {
    public static void printArea(Shape shape) {
        System.out.println("면적: " + shape.getArea());
    }
    
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape rectangle = new Rectangle(4, 6);
        
        printArea(circle);    // 원의 면적
        printArea(rectangle); // 사각형의 면적
    }
}
```
#### 오버로딩
> 같은 이름, 다른 매개변수로 메서드 중복 정
- 컴파일 타임 ("어떤 메서드 시그니처를 찾을지" 결정)
#### 오버라이딩
> 상속받은 메서드를 하위에서 재정의 
- 런타임 (실행시점에 어떤 객체가 연결되어 있을지 미리 모르기 때문)
## 객체지향 설계 원칙 (SOLID)
> 유지보수 가능한 코드를 만드는 규율
### 단일 책임 원칙 (SRP)
> 하나의 클래스는 하나의 책임만
- 클래스는 단 하나의 책임만 가져야 하며, 변경의 이유도 하나여야 합니다. 
### 개방-폐쇄 원칙 (OCP)
> 확장에는 열려있고, 수정에는 닫혀있음
- 기존코드를 수정하지 않으면서 새로운 기능을 추가할 수 있도록 설계 
- 👉 전략 패턴의 근거
#### ❌ OCP 위반 예시 (if-else 지옥)
```
class PaymentService {
    void pay(String type) {
        if (type.equals("CARD")) {
            System.out.println("카드 결제");
        } else if (type.equals("CASH")) {
            System.out.println("현금 결제");
        }
    }
}
```
- 새 결제 수단 추가할 때마다 기존 코드 수정
-OCP ❌
#### ⭕ OCP 준수 예시 (전략 패턴)
- 1️⃣ 추상화
```
interface Payment {
    void pay();
}
```
- 2️⃣ 구현체
```
class CardPayment implements Payment {
    public void pay() { System.out.println("카드 결제"); }
}

class CashPayment implements Payment {
    public void pay() { System.out.println("현금 결제"); }
}
```
- 3️⃣ 사용하는 쪽
```
class PaymentService {
    void pay(Payment payment) {
        payment.pay();
    }
}
```
- ➕ 새 기능 추가 (PaymentService 수정 ❌)
```
class CryptoPayment implements Payment {
    public void pay() { System.out.println("코인 결제"); }
}
```
### 리스코프 치환 원칙 (Liskov Substitution Principle)
> 자식 객체는 부모 객체를 완전히 대체 가능해야 함
- 자식 객체로 대체했을 때, 프로그램의 정확성이 떨어지거나 시스템에 문제가 생기면 안된다 
```
// 나쁜 예 - LSP 위반
class Bird {
    public void fly() {
        System.out.println("날고 있습니다");
    }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("펭귄은 날 수 없습니다");
    }
}

// 좋은 예 - LSP 준수
abstract class Bird {
    abstract void move();
}

class FlyingBird extends Bird {
    @Override
    void move() {
        fly();
    }
    
    private void fly() {
        System.out.println("날고 있습니다");
    }
}

class Penguin extends Bird {
    @Override
    void move() {
        swim();
    }
    
    private void swim() {
        System.out.println("헤엄치고 있습니다");
    }
}

// 모든 Bird 타입을 동일하게 처리 가능
class BirdHandler {
    public void moveBird(Bird bird) {
        bird.move(); // 예외 없이 동작
    }
}
```
### 인터페이스 분리 원칙 (Interface Segregation Principle)
> 사용하지 않는 메서드에 의존하지 않도록 인터페이스 분리
- 범용 인터페이스 ❌
- 목적별 인터페이스 ⭕
```
// 나쁜 예 - 거대한 인터페이스
interface Worker {
    void work();
    void eat();
    void sleep();
    void getPaid();
}

// 로봇은 eat, sleep이 필요 없음
class RobotWorker implements Worker {
    @Override
    public void work() {
        System.out.println("작업 중");
    }
    
    @Override
    public void eat() {
        // 불필요한 구현
    }
    
    @Override
    public void sleep() {
        // 불필요한 구현
    }
    
    @Override
    public void getPaid() {
        // 불필요한 구현
    }
}

// 좋은 예 - 인터페이스 분리
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

interface Sleepable {
    void sleep();
}

interface Payable {
    void getPaid();
}

class HumanWorker implements Workable, Eatable, Sleepable, Payable {
    @Override
    public void work() {
        System.out.println("작업 중");
    }
    
    @Override
    public void eat() {
        System.out.println("식사 중");
    }
    
    @Override
    public void sleep() {
        System.out.println("수면 중");
    }
    
    @Override
    public void getPaid() {
        System.out.println("급여 수령");
    }
}

class RobotWorker implements Workable {
    @Override
    public void work() {
        System.out.println("작업 중");
    }
}
```
### 의존 역전 원칙 (Dependency Inversion Principle)
> 구현이 아닌 추상에 의존
- 구현이 바뀌어도 코드 수정 없음.
- 테스트·확장·유지보수 전부 쉬워진다.
#### ❌ 위반
```
class OrderService {
    private CardPayment payment = new CardPayment();
}
```
#### ⭕ 준수
```
class OrderService {
    private Payment payment;
}
```
# 절차형 프로그래밍
> 명령을 순차적으로 나열해 실행 흐름 제어
- 함수 중심
- 상태 공유 많음
- 규모 커지면 유지보수 어려움
# 패러다임의 혼합
> 상황에 맞게 여러 방식 결합
- 실제 백엔드 예
  - 전체 구조 → 객체지향
  - 데이터 처리 → 함수형 (Stream, map/filter)
  - 초기 스크립트 → 절차형
