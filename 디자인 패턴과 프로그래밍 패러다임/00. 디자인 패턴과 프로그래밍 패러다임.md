# 디자인 패턴 (Design Pattern)
> 코드 설계의 반복적 문제 해결 ‘형태’
- (what) 이미 수많은 개발자들이 경험적으로 검증한 “좋은 코드 구조의 템플릿(해결 패턴)”
- “이럴 때 이렇게 짜면 좋더라를 정리한 설계 공식”
- (why) 복잡한 소프트웨어에서 재사용·유지보수·확장성을 높이기 위해

| 분류    | 내용             | 예시              |
| ----- | -------------- | --------------- |
| 생성 패턴 | 객체 생성 방법 최적화   | 싱글톤, 팩토리, 빌더    |
| 구조 패턴 | 클래스/객체의 관계 구조화 | 어댑터, 데코레이터, 프록시 |
| 행동 패턴 | 객체 간 상호작용/책임   | 전략, 옵저버, 커맨드    |

# 프로그래밍 패러다임 (Programming Paradigm)
> 프로그램을 바라보는 ‘철학’과 ‘방법론’
- (what) “세상을 어떤 방식으로 모델링할지에 대한 철학”
- (why) 문제를 어떤 관점에서 해결할지 결정 → 언어 선택, 설계 방식, 코드 스타일에 영향을 줌

| 패러다임             | 핵심 개념               | 예시 언어                     |
| ---------------- | ------------------- | ------------------------- |
| 절차지향             | 순차적 실행 중심           | C                         |
| 객체지향(OOP)        | 객체 + 메시지            | Java, C#                  |
| 함수형(Functional)  | 부작용 최소화, 순수 함수      | Scala, Haskell, Kotlin 일부 |
| 선언형(Declarative) | “무엇”을 정의, “어떻게”는 숨김 | SQL                       |
| 논리형(Logical)     | 규칙과 추론              | Prolog                    |

| 패러다임                  | 프로그래머가 전제하는 철학(가치 판단)                         |
| --------------------- | --------------------------------------------- |
| 절차지향                  | **논리는 순서에 의해 조직된다** → 제어 흐름이 모든 것의 중심         |
| 객체지향(OOP)             | **복잡도는 책임을 나누고 캡슐화함으로 제어된다** → 의존성 최소화, 역할 중심 |
| 함수형(Functional)       | **예측가능성이 안정성을 만든다** → 상태 변경 금지, 동일 입력 = 동일 출력 |
| 선언형(Declarative)      | **추상화는 생산성을 높인다** → 구현은 숨기고 의도를 표현하는 것이 더 중요  |
| 논리형(Logical)          | **정확한 규칙 정의가 자동화를 가능케 한다** → 추론 엔진이 절차를 대신한다  |
| 이벤트 기반(Event-driven)  | **변화는 독립된 컴포넌트의 반응 체인이다** → 느슨한 결합 + 비동기      |
| 데이터 지향(Data-oriented) | **데이터 구조가 알고리즘을 지배한다** → 데이터 레이아웃 최적화가 성능 핵심  |
| 리액티브(Reactive)        | **시간과 변화는 1급 개체다** → 스트림 기반, 논블로킹             |

# 프로그래밍 패러다임 vs 디자인 패턴
- 패러다임 = 프로그래밍 세계관
- 디자인 패턴 = 그 세계관 안의 실전 기술집

| 구분     | 프로그래밍 패러다임         | 디자인 패턴                |
| ------ | ------------------ | --------------------- |
| 본질     | **철학/사상**          | **구체적 설계 솔루션**        |
| 추상화 수준 | 매우 높음              | 중간                    |
| 적용 범위  | 언어/전체 시스템          | 코드 레벨                 |
| 선택 기준  | 문제를 **어떤 관점**으로 볼까 | 그 관점 안에서 **어떻게 해결할까** |
| 예      | 객체지향, 함수형          | 싱글톤, 전략, 옵저버          |

# 라이브러리와 프레임워크
- 디자인패턴은 라이브러리와 프레임워크의 기본이 된다
## 공통점
- 재사용 가능한 기능 제공
## 차이점
- 흐름을 누가 주도하느냐
- → 라이브러리: 개발자 주도 (ex. 가위)
- → 프레임워크: 프레임워크 주도 (ex. 비행기) 
