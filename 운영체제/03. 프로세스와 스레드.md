# 프로세스 
> 실행 중인 프로그램의 단위
- **프로그램**: HDD/SSD에 저장된 실행 파일(아직 실행 안 됨)
- **프로세스**: 프로그램이 **메모리에 올라가 실행 중인 상태**
- **스레드**: 프로세스 내부에서 실제로 **CPU가 실행하는 작업 흐름**
#### 동작흐름
<img width="417" height="307" alt="image" src="https://github.com/user-attachments/assets/06c6d403-16d7-4075-8a42-1ee414dc83ff" />

1. 프로그램이 HDD/SSD에 있음
2. 실행하면 메모리에 로드 → **프로세스 생성(인스턴스화)**
3. OS의 **CPU 스케줄러**가 어떤 프로세스를 실행할지 결정
4. CPU가 선택된 프로세스(정확히는 그 안의 스레드)를 실행
# 프로세스와 컴파일 과정 
> **프로세스** = 컴파일이 끝난 실행 파일이 메모리에 올라가 실행되는 상태
## 컴파일 과정 (C 기준)
> **목적: 소스 코드 → 실행 가능한 파일**
<img width="668" height="541" alt="image" src="https://github.com/user-attachments/assets/1a6f5d4b-b2c5-4073-ad37-00175fe0f373" />

### 전처리 (Preprocessing)
- 주석 제거
- `#include`로 포함된 헤더 파일 내용 병합
- `#define` 매크로 치환
- **결과물**: 순수 C 코드 (아직 기계어 아님)
### 컴파일러 (Compiler)
- 고급언어 → **어셈블리 코드**로 변환
- 문법 오류, 타입 오류 여기서 잡힘
### 어셈블러 (Assembler)
- 어셈블리 → **기계어(Object file)** 변환

- .o 파일 생성
### 링커 (Linker)
- 여러 object 파일을 하나의 실행 파일로 결합
- 함수/변수 주소를 실제 메모리 주소로 연결
#### 정적 라이브러리와 동적 라이브러리
- **정적 라이브러리**
  - 빌드 시 실행 파일에 포함
  - 👍 외부 의존성 낮음 / 👎 실행 파일 큼
- **동적 라이브러리**
  - 실행 시 필요할 때 로드(DLL, so)
  - 👍 메모리 효율 / 👎 외부 의존성 높음 (ex. 경로나 버전이 다름)
# 프로세스의 상태
> 프로세스는 실행 ↔ 대기 ↔ 중단을 반복하는 상태 머신이다.
<img width="465" height="210" alt="image" src="https://github.com/user-attachments/assets/e45f7d77-bd75-4e1d-9ae4-56338927a3e2" />

- 프로세스는 실행 동안 여러 상태를 오가며 CPU와 메모리를 사용한다.
- 핵심은 “**CPU를 쓰고 있나?**”, “**메모리에 있나?**”, “**무엇을 기다리나?**”다.
## 생성 상태 (Created / New)
- 프로세스가 막 만들어진 상태
- **PCB(Process Control Block)** 가 생성됨
- 주소 공간 할당 준비 단계
### `fork()`
- **부모 프로세스의 주소 공간을 복사**해 자식 생성
- 실제로는 **Copy-on-Write**: 메모리 공유하다가(read-only) 쓰기(write)할 때 복제
- PID는 새로 부여
### `exec()`
> **현재 프로세스의 코드/데이터를 새 프로그램으로 교체**
- PID 유지
- “새 프로세스를 만드는 함수”가 아니라 **프로세스 내용 교체**
## 대기 상태 (Ready)
> **CPU만 기다리는 상태**
## 대기 중단 상태 (Ready Suspended)
> Ready상태에서 메모리 부족으로 swap out된 상태  
## 실행 상태 (Running)
> CPU를 실제로 점유하여 명령어 실행 중
- 타임 슬라이스가 끝나면 Ready로 돌아감
- 이 구간을 CPU burst라고도 부름
## 중단 상태 (Blocked / Waiting)
> CPU가 아니라 **외부 사건**을 기다림
- I/O, 이벤트, 락 등을 기다림
- CPU를 줘도 쓸 수 없는 상태
- 예: 디스크 읽기, 네트워크 응답 대기
## 일시 중단 상태 (Blocked Suspended) 
- Blocked 상태에서, 메모리 부족으로 swap out된 상태 
## 종료 상태
- 메모리와 CPU 등 자원 반납 
- 정상 종료 or 비정상 종료(abort)
- 부모가 wait()로 회수하기 전까지 좀비로 남을 수 있음 (부모가 자식의 종료상태를 확인하기 위한 정보들) 
# 프로세스의 메모리 구조
- 프로세스는 “역할별로 분리된 메모리 영역”을 가진다.
<img width="338" height="312" alt="image" src="https://github.com/user-attachments/assets/b29e7c14-6692-487c-95e4-7c153a476cb0" />

## 스택과 힙
- 동적 할당
- 런타임 단계에서 메모리를 할당 
### 스택 (Stack)
- 함수 호출용 메모리
- 지역 변수, 매개변수, 리턴 주소
- **위 → 아래로 성장**
- 함수 호출/복귀 시 자동 관리
### 힙 (Heap)
- **동적 할당 메모리**
- `malloc`, `free`, `new`, `delete`
- **아래 → 위로 성장**
- 개발자가 직접 관리 (Java는 GC가)
## 데이터 영역과 코드 영역
- 정적 할당
- 컴파일 단계에서 메모리를 할당
### 데이터 영역
- Data segment
  - 초기값 **있는** 전역변수 / static 변수
- BSS segment
  - 초기값 **없는** 전역변수 / static 변수 (없거나 0)
  - 실행파일에 변수크기만 써놓고, 내용물은 채우지 않음
  - 실행파일의 크기를 줄이기 위함. (메모리가 아니라 디스크 공간 절약, 로딩 속도 향상) 
### 코드 영역 (Code / Text)
- **실행 코드**
- 컴파일 결과
- 보통 읽기 전용
# PCB (Process Control Block)
> OS가 관리하는 프로세스 메타데이터
- 프로세스의 신분증 + 문맥 세이브파일 
- 커널 스택의 가장 앞부분에서 관리
## PCB의 구조
- PID
- 프로세스 상태
- 프로그램 카운터(다음 실행 위치)
- 레지스터 값
- 스케줄링 정보
- 메모리 정보
- 등등
- 👉 이 프로세스를 중단했다가 다시 이어서 실행하기 위한 정보들
## 컨텍스트 스위칭
> CPU가 프로세스를 바꿀 때 상태를 저장·복원하는 작업
<img width="603" height="529" alt="image" src="https://github.com/user-attachments/assets/cc161042-f124-4885-a421-d8ac0423abfa" />

- 이때 커널이 하는 일:
  - A의 CPU 레지스터 값 → A의 PCB에 저장
  - B의 PCB에 있던 레지스터 값 → CPU에 복원
  - B 실행 시작
### 비용: 캐시미스
- CPU 캐시에 “이전 프로세스의 데이터”가 남아 있을 때 
### 스레드에서의 컨텍스트 스위칭
- 스레드의 경우, 스택 빼고는 메모리 공유
- 비용이 더 적고 시간도 더 적게 걸림 
# 멀티 프로세싱
> 여러 프로세스를 동시에 실행 (격리 강함, 비용 큼)
- 각 프로세스는:
  - 독립된 메모리 공간
  - 서로 직접 메모리 접근 ❌
  - 대신 IPC로 통신
- 장점
  - 하나가 죽어도 전체 안 죽음 (안정성)
  - 보안 격리
  - 병렬 처리 가능
- 단점
  - 프로세스 생성 비용 큼
  - IPC 비용 있음
## 예시) 웹 브라우저
<img width="518" height="354" alt="image" src="https://github.com/user-attachments/assets/ff4aac05-447a-46d0-bd72-13cedd1bc9af" />

- 브라우저 프로세스 (UI)
- 렌더러 프로세스 (탭마다)
- 플러그인 프로세스
- GPU 프로세스
- 👉 탭 하나 죽어도 전체 브라우저 안 죽는 이유
## IPC (Inter-Process Communication)
> 프로세스 간 통신 방법
- 프로세스는 메모리를 공유하지 않기 때문에, 통신 수단이 필요하다.
- ex) 같은 컴퓨터 안에서 클라이언트-서버 통신 
### 공유 메모리
> 여러 프로세스가 동일한 메모리 블록 공유
<img width="278" height="173" alt="image" src="https://github.com/user-attachments/assets/a1f0cf3e-8ac3-4b21-8e84-b571d9370f05" />

- 가장 빠름 (데이터 복사 오버헤드x) 
- 동기화 필요 (락 필요)
### 파일
> 디스크(or 파일서버)의 파일을 매개체로 통신
- 디스크에 저장된 데이터 or 파일 서버에서 제공하는 데이터
- 를 기반으로 프로세스간 통신
- 구현 간단, 느림 
### 소켓
> 네트워크로 통신 
- 로컬 내 다른 프로세스 or 네트워크의 다른 컴퓨터 프로세스 
- 서버 프로그래밍 핵심
- TCP/UDP 
### 익명 파이프
> FIFO방식으로 읽는 임시 공간 파이프로 통신
<img width="520" height="144" alt="image" src="https://github.com/user-attachments/assets/f566fe49-75a5-4d53-8a85-4e8c27a15e7b" />

- 파이프 : 한 프로세스의 출력(Output)을 다른 프로세스의 입력(Input)으로 바로 연결하는 통로 
- 부모-자식 간 단방향
  - 양방향 하려면 파이프 2개 
- 익명이라 외부 프로세스는 이용불가
### 명명된 파이프
> 이름이 주소역할하는 파이프로 프로세스 간 양방향 통신 수행
<img width="642" height="254" alt="image" src="https://github.com/user-attachments/assets/18fff56a-4107-465d-8e3e-afcf1debfa89" />

- 확장성: 파이프 서버와 하나 이상의 파이프 클라이언트 간의 통신을 지원
- 방향성: 단방향뿐만 아니라 양방향 통신도 가능
- 네트워크: 같은 컴퓨터 내의 프로세스뿐만 아니라, 다른 네트워크상의 컴퓨터와도 통신할 수 있다는 점이 큰 장점
### 메시지 큐
# 스레드와 멀티스레딩
## 스레드
## 멀티스레딩
# 공유 자원과 임계 영역
## 공유 자원
## 임계 영역
### 뮤텍스
### 세마포어
#### 바이너리 세마포어
#### 카운팅 세마포어
### 모니터
# 교착 상태
## 교착 상태의 원인
## 교착 상태의 해결 방법
