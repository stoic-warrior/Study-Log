# 프로세스 
> 실행 중인 프로그램의 단위
- **프로그램**: HDD/SSD에 저장된 실행 파일(아직 실행 안 됨)
- **프로세스**: 프로그램이 **메모리에 올라가 실행 중인 상태**
- **스레드**: 프로세스 내부에서 실제로 **CPU가 실행하는 작업 흐름**
#### 동작흐름
<img width="417" height="307" alt="image" src="https://github.com/user-attachments/assets/06c6d403-16d7-4075-8a42-1ee414dc83ff" />

1. 프로그램이 HDD/SSD에 있음
2. 실행하면 메모리에 로드 → **프로세스 생성(인스턴스화)**
3. OS의 **CPU 스케줄러**가 어떤 프로세스를 실행할지 결정
4. CPU가 선택된 프로세스(정확히는 그 안의 스레드)를 실행
# 프로세스와 컴파일 과정 
> **프로세스** = 컴파일이 끝난 실행 파일이 메모리에 올라가 실행되는 상태
## 컴파일 과정 (C 기준)
> **목적: 소스 코드 → 실행 가능한 파일**
<img width="668" height="541" alt="image" src="https://github.com/user-attachments/assets/1a6f5d4b-b2c5-4073-ad37-00175fe0f373" />

### 전처리 (Preprocessing)
- 주석 제거
- `#include`로 포함된 헤더 파일 내용 병합
- `#define` 매크로 치환
- **결과물**: 순수 C 코드 (아직 기계어 아님)
### 컴파일러 (Compiler)
- 고급언어 → **어셈블리 코드**로 변환
- 문법 오류, 타입 오류 여기서 잡힘
### 어셈블러 (Assembler)
- 어셈블리 → **기계어(Object file)** 변환

- .o 파일 생성
### 링커 (Linker)
- 여러 object 파일을 하나의 실행 파일로 결합
- 함수/변수 주소를 실제 메모리 주소로 연결
#### 정적 라이브러리와 동적 라이브러리
- **정적 라이브러리**
  - 빌드 시 실행 파일에 포함
  - 👍 외부 의존성 낮음 / 👎 실행 파일 큼
- **동적 라이브러리**
  - 실행 시 필요할 때 로드(DLL, so)
  - 👍 메모리 효율 / 👎 외부 의존성 높음 (ex. 경로나 버전이 다름)
# 프로세스의 상태
## 생성 상태
### fork()
### exec()
## 대기 상태
## 대기 중단 상태
## 실행 상태
## 중단 상태
## 일시 중단 상태
## 종료 상태
# 프로세스의 메모리 구조
## 스택과 힙
## 데이터 영역과 코드 영역
# PCB
## PCB의 구조
## 컨텍스트 스위칭
### 비용: 캐시미스
### 스레드에서의 컨텍스트 스위칭
# 멀티 프로세싱
## 웹 브라우저
## IPC
### 공유 메모리
### 파일
### 소켓
### 익명 파이프
### 명명된 파이프
### 메시지 큐
# 스레드와 멀티스레딩
## 스레드
## 멀티스레딩
# 공유 자원과 임계 영역
## 공유 자원
## 임계 영역
### 뮤텍스
### 세마포어
#### 바이너리 세마포어
#### 카운팅 세마포어
### 모니터
# 교착 상태
## 교착 상태의 원인
## 교착 상태의 해결 방법
