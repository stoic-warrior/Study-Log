# 운영체제의 역할과 구조
> 하드웨어를 관리하고 사용자에겐 편의를 제공하는 시스템
## 운영체제의 역할
- **CPU/프로세스 관리**: CPU 스케줄링, 프로세스 생성·삭제, 자원 할당/반환
- **메모리 관리**: 프로세스별 메모리 할당·회수
- **디스크/파일 관리**: 파일 저장 방식, 파일 시스템 관리
- **I/O 디바이스 관리**: 키보드·마우스·디스크 같은 입출력 장치와 프로그램 사이의 데이터 전송을 관리
  - I/O : CPU/메모리를 제외한 나머지와 입출력 상호작용 하는 것
## 운영체제의 구조
<img width="262" height="250" alt="image" src="https://github.com/user-attachments/assets/f2365122-35d5-469b-90ea-2d859c0c78d6" />

- **운영체제(OS)**: 인터페이스 + 시스템 콜 + 커널 + 드라이버(등)
- **GUI**: 그래픽 기반 인터페이스
- **CUI**: 명령어 기반 인터페이스
- **드라이버**: 하드웨어 제어용 소프트웨어
### 시스템콜
> 유저 프로그램이 커널 기능을 사용하기 위해 호출
- **왜 필요한가?**
  - 유저 프로그램이 **직접 하드웨어 접근하면 위험**
  - 시스템 콜을 통해서만 **검증된 방식**으로 접근 가능
- 파일 읽기 (`read`)
- 네트워크 송신 (`send`)
- 프로세스 생성 (`fork`)
- 메모리 할당 (`mmap`)
#### 예시
<img width="414" height="289" alt="image" src="https://github.com/user-attachments/assets/fbe541cc-9b80-4aaf-8c5b-db40e6647a92" />

- 유저 프로그램이 fs.readFile() 같은 I/O 요청을 한다
- 시스템 콜이 발생하면서 trap이 걸린다
- CPU가 유저 모드 → 커널 모드로 전환된다
- 커널이 파일 시스템/드라이버를 통해 실제 작업을 수행한다
- 작업이 끝나면 커널 모드 → 유저 모드로 돌아간다
- 유저 프로그램은 결과만 받아 다음 로직을 실행한다
#### modebit
> CPU가 현재 유저 모드인지, 커널 모드인지를 구분하는 비트
<img width="601" height="320" alt="image" src="https://github.com/user-attachments/assets/954d66a9-ef53-4ade-ab98-86bb0ef2b2b6" />

- `mode bit = 1` → 유저 모드
- `mode bit = 0` → 커널 모드
- 시스템 콜이나 인터럽트가 발생할 때만
- → mode bit이 바뀌며 커널 코드 실행이 허용된다
# 컴퓨터의 요소
<img width="769" height="463" alt="image" src="https://github.com/user-attachments/assets/1016384d-38da-4735-a50b-e729321bbfc0" />

## CPU (Central Processing Unit)
> 메모리에 올라온 명령어를 읽고, 해석하고, 실행하는 '컴퓨터의 일꾼'
<img width="422" height="334" alt="image" src="https://github.com/user-attachments/assets/71d08569-5144-4398-9158-0c49b5fc0241" />

- 관리자인 OS의 커널이 프로그램을 메모리에 올려 프로세스로 만들면 일꾼인 CPU가 이를 처리한다
- 명령어를 가져오고(fetch)
- 해석하고(decode)
- 실행(execute)
### ① 제어장치 (CU, Control Unit)
> CPU 내부의 지휘자
- 어떤 명령을 실행할지 결정하고 각 부품에 신호 전달
  - 메모리에서 **명령어를 가져오고(fetch)**
  - 명령어를 **해석(decode)**
  - 어떤 연산을 할지 결정하고
  - 레지스터, ALU, 메모리에게 **“누가 무엇을 언제 할지”** 지시
- 즉, 제어장치가 없으면 CPU 부품들은 **각자 뭘 해야 할지 모르는 상태**가 된다.
### ② 레지스터 (Register)
> CPU 내부에 있는 초고속 임시 저장소
- 메모리(RAM)보다 **수십~수백 배 빠름**
- 연산에 필요한 값, 주소, 상태를 잠깐 저장
- CPU는 메모리에서 직접 계산하지 않고 레지스터에 값을 올려놓고 연산한다
- 대표 레지스터:
  - PC (Program Counter): 다음 실행할 명령어 주소
  - IR (Instruction Register): 현재 명령어
  - 범용 레지스터: 연산 데이터 저장
### ③ 산술논리연산장치 (ALU)
> 실제 계산 담당 부품
- 산술 연산: 덧셈, 뺄셈, 곱셈, 나눗셈
- 논리 연산: AND, OR, NOT, 비교(>, <, =)
#### CPU의 연산처리
<img width="751" height="491" alt="image" src="https://github.com/user-attachments/assets/9f921a3c-8917-4f55-8f3a-61f420079215" />

- ① 메모리 → 레지스터 로드 (제어장치가 로드)
- ② 레지스터 → ALU 연산 (제어장치가 ALU에 명령)
- ③ 결과를 다시 저장 (제어장치가 결과값을 레지스터에서 메모리로 저장) 
### 인터럽트 (Interrupt)
> CPU에게 “잠깐 멈추고 이거부터 처리해”라고 알리는 신호
- 처리 흐름
  - 인터럽트 발생
  - CPU가 현재 상태 저장(레지스터/PC 등)
  - 인터럽트 벡터에서 해당 핸들러 주소 찾음
  - 핸들러 실행
  - 원래 작업으로 복귀
- 인터럽트 핸들러 함수 : 인터럽트가 발생했을 때 실행되는 커널 함수
#### 하드웨어 인터럽트
외부 장치에서 발생
예:
키보드 입력
디스크 I/O 완료
네트워크 패킷 도착
#### 소프트웨어 인터럽트(trap) 
프로그램 내부에서 발생
대표적 예: 시스템 콜
## DMA 컨트롤러
## 메모리
## 타이머
## 디바이스 컨트롤러
