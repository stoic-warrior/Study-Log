# 비선형 자료 구조
- 데이터가 일렬(선형)로 배치되지 않고
- **계층적(Hierarchical)** 또는 **망형(Network)**으로 연결된 구조
- 주로 트리나 그래프 
# 그래프 (Graph)
> 정점과 간선으로 이루어진 자료구조
- 정점(Vertex): 개체(노드)
- 간선(Edge): 정점 간 연결. 방향성 있을 수도 있음.
- 가중치(Weight): 간선에 부여된 비용/거리/시간.
- 👉 활용: SNS 친구 관계, 네트워크 라우팅, 최단 경로 알고리즘(Dijkstra, Floyd-Warshall).
# 트리
> 사이클 없는 연결 그래프. 루트에서 시작해 계층 구조를 이룸.
- 부모와 자식이 구분되는 상황에선 방향성 그래프, 스패닝 트리 같은 상황에서는 무방향 그래프
## 트리의 특징
- 하나의 루트 노드(root).
- 간선 수 = 노드 수 - 1.
- 사이클 없음.
## 트리의 구성
- 루트 노드: 최상위 시작점.
- 내부 노드: 자식이 있는 노드.
- 리프 노드: 자식 없는 노드.
### 트리의 높이와 레벨
<img width="460" height="322" alt="image" src="https://github.com/user-attachments/assets/21cd44ff-a20e-47d1-aac4-b8ac3a2c70fc" />

- 레벨(Level): 루트에서부터의 거리. (루트 : 0 or 1)
- 높이(Height): 가장 깊은 리프까지의 최대 레벨.
## 이진 트리 (Binary Tree)
- 각 노드가 최대 2개의 자식(왼쪽·오른쪽).
## 이진 탐색 트리 (BST, Binary Search Tree)
<img width="521" height="268" alt="image" src="https://github.com/user-attachments/assets/51d70de1-8502-485b-8d7b-cb4cf81004f3" />
<img width="632" height="432" alt="image" src="https://github.com/user-attachments/assets/72040272-c052-49eb-9947-750f335595f4" />


- **값** : 왼쪽 자식 < 부모 < 오른쪽 자식.
- **탐색/삽입/삭제**: 평균 O(log N), 최악 O(N).
## AVL 트리 (Adelson–Velsky and Landis Tree)
> 균형 잡힌 이진 탐색 트리(Balanced BST)
- 이진 탐색 트리가 선형적으로 되는걸 방지하고자, 삽입/삭제시 불균형 발생하면 회전을 한다
- 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 최대 1 이하.
- 탐색, 삽입, 삭제 = O(log N)
- **단점** : 삽입/삭제가 많은경우 회전 연산으로 성능 손실 가능
## 레드 블랙 트리
> 느슨한 균형 잡힌 이진 탐색 트리
- 삽입/삭제 시 노드 색(빨강/검정) 규칙과 회전을 이용해 균형을 유지.
- 모든 연산(탐색·삽입·삭제): O(log N) 보장.
### 규칙
- 루트는 항상 검정(Black).
- 리프(NIL) 노드는 항상 검정.
- 빨강 노드의 자식은 반드시 검정 (연속된 빨강 금지).
- 어떤 노드에서 리프까지 가는 모든 경로의 검정 노드 개수는 동일.
- 삽입/삭제 시 이 규칙을 깨뜨리면 → 재색칠(Recoloring), **회전(Rotation)**으로 복구.
### 특징
- 균형 유지가 느슨함
  - AVL은 더 “빡세게” 균형을 맞추지만, 레드-블랙은 일부 불균형 허용.
  - 덕분에 삽입/삭제가 AVL보다 빠름
- 탐색 속도는 AVL보다 약간 느릴 수 있음 (균형 정도 차이).
## AVL vs Red-Black 비교
| 구분    | AVL 트리          | 레드-블랙 트리       |
| ----- | --------------- | -------------- |
| 균형 정도 | 더 엄격 (높이 차 ≤ 1) | 느슨 (검정 높이만 같음) |
| 탐색    | 더 빠름 (엄격 균형)    | 약간 느림          |
| 삽입/삭제 | 회전 잦음 (비용 ↑)    | 회전 적음 (비용 ↓)   |
| 실무 활용 | 탐색 최적화 환경       | 일반 목적(Map/Set) |

# 힙
> 완전 이진 트리 기반의 우선순위 자료구조
- 완전 이진 트리 : 왼쪽부터 차례대로 노드를 채워나가는 이진 트리
- 최대 힙: 부모 ≥ 자식. 루트 = 최댓값.
- 최소 힙: 부모 ≤ 자식. 루트 = 최솟값.
<img width="768" height="300" alt="image" src="https://github.com/user-attachments/assets/873fcd49-e164-4221-a858-e1ff20c601f3" />
<img width="759" height="552" alt="image" src="https://github.com/user-attachments/assets/765cd234-c1a4-479c-99a1-2a549e6f531f" />


## 최대힙의 삽입
- 마지막 리프에 노드 삽입.
- 부모와 비교하며 위로 올라감(Heapify Up).
- 시간복잡도: O(log N).
## 최대힙의 삭제
- 루트 제거(최댓값).
- 마지막 원소를 루트로 옮김. (완전 이진 트리 유지하기 위해 마지막 원소 선택)
- 자식과 비교하며 아래로 내려감(Heapify Down).
- 시간복잡도: O(log N).
# 우선순위 큐
- 보통 힙으로 구현. (우선순위큐 = 추상적 자료형(ADT), 힙 = 구현체)
- 삽입 O(log N), 삭제 O(log N).
- 항상 우선순위가 가장 높은 원소를 빠르게 꺼낼 수 있음.
# 맵
- **키-값 쌍 저장**
- 키 중복 불가, 값 중복 가능.
- 구현: 해시 테이블(평균 O(1)), 트리맵(레드블랙 트리 기반, O(log N)).
# 셋
- 중복 없는 원소 집합.
- 구현: 해시셋(평균 O(1)), 트리셋(O(log N)).
- 활용: 유니크 값 관리, 집합 연산(합집합, 교집합).
# 해시 테이블
- **해시 함수**로 키를 인덱스로 변환 후 값 저장.
- 평균 삽입/검색/삭제: O(1).
- 해시 충돌 해결 방식: 체이닝(Linked List), 오픈 어드레싱(Linear Probing, Quadratic Probing, Double Hashing).
- 실무: DB 인덱스, 캐시, 파라미터 맵핑, 로드 밸런싱.
# 요약
- 트리 = 계층 구조 (DB 인덱스, 디렉터리 구조).
- 그래프 = 네트워크/관계 (SNS, 경로 탐색).
- 힙/우선순위 큐 = 스케줄링 (CPU 스케줄러, 다익스트라).
- 맵/셋/해시 = 빠른 검색과 중복 관리 (캐시, 딕셔너리, 로그인 세션).
